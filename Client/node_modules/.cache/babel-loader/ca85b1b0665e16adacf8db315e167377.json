{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { IgrTimeAxisBreakCollection } from \"./igr-time-axis-break-collection\";\nimport { TimeAxisLabellingMode_$type } from \"./TimeAxisLabellingMode\";\nimport { IgrTimeAxisLabelFormatCollection } from \"./igr-time-axis-label-format-collection\";\nimport { IgrTimeAxisIntervalCollection } from \"./igr-time-axis-interval-collection\";\nimport { IgrTimeAxisBase } from \"./igr-time-axis-base\";\nimport { TimeXAxis } from \"./TimeXAxis\";\nimport { ensureEnum } from \"igniteui-react-core\";\nimport { TimeAxisBreakCollection as TimeAxisBreakCollection_internal } from \"./TimeAxisBreakCollection\";\nimport { TimeAxisBreak } from \"./TimeAxisBreak\";\nimport { SyncableObservableCollection$1 } from \"igniteui-react-core\";\nimport { TimeAxisLabelFormatCollection as TimeAxisLabelFormatCollection_internal } from \"./TimeAxisLabelFormatCollection\";\nimport { TimeAxisLabelFormat } from \"./TimeAxisLabelFormat\";\nimport { TimeAxisIntervalCollection as TimeAxisIntervalCollection_internal } from \"./TimeAxisIntervalCollection\";\nimport { TimeAxisInterval } from \"./TimeAxisInterval\";\n/**\n * A horizontal axis that uses a DateTime scale.\n*\n* The `IgrTimeXAxis` is a horizontal axis that uses a DateTime scale.\n*\n* ```ts\n*   <IgrDataChart\n*     dataSource={this.state.dataSource}\n*     width=\"700px\"\n*     height=\"500px\">\n*     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n* \t\t\tdateTimeMemberPath=\"Date\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.timeXAxis = new IgrTimeXAxis({name: \"timeXAxis\"});\n* this.timeXAxis.title = \"Time X Axis\";\n* this.timeXAxis.dataSource = this.financialData;\n* this.timeXAxis.dateTimeMemberPath = \"Time\";\n* ```\n*/\n\nvar IgrTimeXAxis =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  __extends(IgrTimeXAxis, _super);\n\n  function IgrTimeXAxis(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._breaks = null;\n    _this._labelFormats = null;\n    _this._intervals = null;\n    return _this;\n  }\n\n  IgrTimeXAxis.prototype.createImplementation = function () {\n    return new TimeXAxis();\n  };\n\n  Object.defineProperty(IgrTimeXAxis.prototype, \"i\", {\n    /**\n                                 * @hidden\n                                 */\n    get: function () {\n      return this._implementation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"isPiecewise\", {\n    get: function () {\n      return this.i.cf;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"breaks\", {\n    /**\n     * TimeAxisBreaks to apply to this axis, representing spans of time to omit, such as weekends.\n    *\n    * The `breaks` to apply to this axis, representing spans of time to omit, such as weekends.\n    *\n    * ```ts\n    *   <IgrDataChart\n    *     dataSource={this.state.dataSource}\n    *     width=\"700px\"\n    *     height=\"500px\">\n    *     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n    * \t\t\tdateTimeMemberPath=\"Date\" >\n    *  </IgrTimeXAxis>\n    *  </IgrDataChart>\n    * ```\n    */\n    get: function () {\n      if (this._breaks === null) {\n        var coll = new IgrTimeAxisBreakCollection();\n        var innerColl = this.i.breaks;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisBreakCollection_internal();\n        }\n\n        this._breaks = coll._fromInner(innerColl);\n      }\n\n      return this._breaks;\n    },\n    set: function (v) {\n      if (this._breaks !== null) {\n        this._breaks._setSyncTarget(null);\n\n        this._breaks = null;\n      }\n\n      var coll = new IgrTimeAxisBreakCollection();\n      this._breaks = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisBreak.$type);\n      var innerColl = this.i.breaks;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisBreakCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._breaks._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"labellingMode\", {\n    /**\n     * Gets or sets the labelling mode to use when the automatic label formats are applied.\n    */\n    get: function () {\n      return this.i.m7;\n    },\n    set: function (v) {\n      this.i.m7 = ensureEnum(TimeAxisLabellingMode_$type, v);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"labelFormats\", {\n    /**\n     * A list of axis label formats to apply, which are selected according to the visible axis range.\n     * The label format selected will be the one with the largest range smaller than the visible range of the axis.\n    */\n    get: function () {\n      if (this._labelFormats === null) {\n        var coll = new IgrTimeAxisLabelFormatCollection();\n        var innerColl = this.i.labelFormats;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisLabelFormatCollection_internal();\n        }\n\n        this._labelFormats = coll._fromInner(innerColl);\n      }\n\n      return this._labelFormats;\n    },\n    set: function (v) {\n      if (this._labelFormats !== null) {\n        this._labelFormats._setSyncTarget(null);\n\n        this._labelFormats = null;\n      }\n\n      var coll = new IgrTimeAxisLabelFormatCollection();\n      this._labelFormats = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisLabelFormat.$type);\n      var innerColl = this.i.labelFormats;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisLabelFormatCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._labelFormats._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"intervals\", {\n    /**\n     * A list of axis label intervals to apply, which are selected according to the visible axis range.\n     * The interval selected will be the one with the largest range smaller than the visible range of the axis.\n    */\n    get: function () {\n      if (this._intervals === null) {\n        var coll = new IgrTimeAxisIntervalCollection();\n        var innerColl = this.i.intervals;\n\n        if (!innerColl) {\n          innerColl = new TimeAxisIntervalCollection_internal();\n        }\n\n        this._intervals = coll._fromInner(innerColl);\n      }\n\n      return this._intervals;\n    },\n    set: function (v) {\n      if (this._intervals !== null) {\n        this._intervals._setSyncTarget(null);\n\n        this._intervals = null;\n      }\n\n      var coll = new IgrTimeAxisIntervalCollection();\n      this._intervals = coll._fromOuter(v);\n      var syncColl = new SyncableObservableCollection$1(TimeAxisInterval.$type);\n      var innerColl = this.i.intervals;\n\n      if (!innerColl) {\n        innerColl = new TimeAxisIntervalCollection_internal();\n      }\n\n      syncColl._inner = innerColl;\n      syncColl.clear();\n\n      this._intervals._setSyncTarget(syncColl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(IgrTimeXAxis.prototype, \"isCategoryDateTime\", {\n    /**\n     * Gets if the current axis is of category date time axis type\n    */\n    get: function () {\n      return this.i.b7;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  IgrTimeXAxis.prototype.findByName = function (name) {\n    var baseResult = _super.prototype.findByName.call(this, name);\n\n    if (baseResult) {\n      return baseResult;\n    }\n\n    if (this.breaks != null && this.breaks.findByName && this.breaks.findByName(name)) {\n      return this.breaks.findByName(name);\n    }\n\n    if (this.labelFormats != null && this.labelFormats.findByName && this.labelFormats.findByName(name)) {\n      return this.labelFormats.findByName(name);\n    }\n\n    if (this.intervals != null && this.intervals.findByName && this.intervals.findByName(name)) {\n      return this.intervals.findByName(name);\n    }\n\n    return null;\n  };\n\n  IgrTimeXAxis.prototype.getValueLabel = function (value) {\n    var iv = this.i.fw(value);\n    return iv;\n  };\n  /**\n   * Gets the index of the data item with the value nearest the given value.\n  \r\n  * @param unscaledValue  * The value to find a value close to.\n  */\n\n\n  IgrTimeXAxis.prototype.getIndexClosestToUnscaledValue = function (unscaledValue) {\n    var iv = this.i.i$f(unscaledValue);\n    return iv;\n  };\n\n  return IgrTimeXAxis;\n}(IgrTimeAxisBase);\n\nexport { IgrTimeXAxis };","map":{"version":3,"sources":["../../../../src/igniteui-charts/lib/igr-time-x-axis.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { IgrTimeAxisBreakCollection } from \"./igr-time-axis-break-collection\";\nimport { TimeAxisLabellingMode_$type } from \"./TimeAxisLabellingMode\";\nimport { IgrTimeAxisLabelFormatCollection } from \"./igr-time-axis-label-format-collection\";\nimport { IgrTimeAxisIntervalCollection } from \"./igr-time-axis-interval-collection\";\nimport { IgrTimeAxisBase } from \"./igr-time-axis-base\";\nimport { TimeXAxis } from \"./TimeXAxis\";\nimport { ensureEnum } from \"igniteui-react-core\";\nimport { TimeAxisBreakCollection as TimeAxisBreakCollection_internal } from \"./TimeAxisBreakCollection\";\nimport { TimeAxisBreak } from \"./TimeAxisBreak\";\nimport { SyncableObservableCollection$1 } from \"igniteui-react-core\";\nimport { TimeAxisLabelFormatCollection as TimeAxisLabelFormatCollection_internal } from \"./TimeAxisLabelFormatCollection\";\nimport { TimeAxisLabelFormat } from \"./TimeAxisLabelFormat\";\nimport { TimeAxisIntervalCollection as TimeAxisIntervalCollection_internal } from \"./TimeAxisIntervalCollection\";\nimport { TimeAxisInterval } from \"./TimeAxisInterval\";\n/**\n * A horizontal axis that uses a DateTime scale.\n*\n* The `IgrTimeXAxis` is a horizontal axis that uses a DateTime scale.\n*\n* ```ts\n*   <IgrDataChart\n*     dataSource={this.state.dataSource}\n*     width=\"700px\"\n*     height=\"500px\">\n*     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n* \t\t\tdateTimeMemberPath=\"Date\" />\n*  </IgrDataChart>\n* ```\n*\n* ```ts\n* this.timeXAxis = new IgrTimeXAxis({name: \"timeXAxis\"});\n* this.timeXAxis.title = \"Time X Axis\";\n* this.timeXAxis.dataSource = this.financialData;\n* this.timeXAxis.dateTimeMemberPath = \"Time\";\n* ```\n*/\nvar IgrTimeXAxis = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(IgrTimeXAxis, _super);\n    function IgrTimeXAxis(props) {\n        var _this = _super.call(this, props) || this;\n        _this._breaks = null;\n        _this._labelFormats = null;\n        _this._intervals = null;\n        return _this;\n    }\n    IgrTimeXAxis.prototype.createImplementation = function () {\n        return new TimeXAxis();\n    };\n    Object.defineProperty(IgrTimeXAxis.prototype, \"i\", {\n        /**\n                                     * @hidden\n                                     */\n        get: function () {\n            return this._implementation;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"isPiecewise\", {\n        get: function () {\n            return this.i.cf;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"breaks\", {\n        /**\n         * TimeAxisBreaks to apply to this axis, representing spans of time to omit, such as weekends.\n        *\n        * The `breaks` to apply to this axis, representing spans of time to omit, such as weekends.\n        *\n        * ```ts\n        *   <IgrDataChart\n        *     dataSource={this.state.dataSource}\n        *     width=\"700px\"\n        *     height=\"500px\">\n        *     <IgrTimeXAxis name=\"xAxis\" label=\"Date\"\n        * \t\t\tdateTimeMemberPath=\"Date\" >\n        *  </IgrTimeXAxis>\n        *  </IgrDataChart>\n        * ```\n        */\n        get: function () {\n            if (this._breaks === null) {\n                var coll = new IgrTimeAxisBreakCollection();\n                var innerColl = this.i.breaks;\n                if (!innerColl) {\n                    innerColl = new TimeAxisBreakCollection_internal();\n                }\n                this._breaks = coll._fromInner(innerColl);\n            }\n            return this._breaks;\n        },\n        set: function (v) {\n            if (this._breaks !== null) {\n                this._breaks._setSyncTarget(null);\n                this._breaks = null;\n            }\n            var coll = new IgrTimeAxisBreakCollection();\n            this._breaks = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisBreak.$type);\n            var innerColl = this.i.breaks;\n            if (!innerColl) {\n                innerColl = new TimeAxisBreakCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._breaks._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"labellingMode\", {\n        /**\n         * Gets or sets the labelling mode to use when the automatic label formats are applied.\n        */\n        get: function () {\n            return this.i.m7;\n        },\n        set: function (v) {\n            this.i.m7 = ensureEnum(TimeAxisLabellingMode_$type, v);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"labelFormats\", {\n        /**\n         * A list of axis label formats to apply, which are selected according to the visible axis range.\n         * The label format selected will be the one with the largest range smaller than the visible range of the axis.\n        */\n        get: function () {\n            if (this._labelFormats === null) {\n                var coll = new IgrTimeAxisLabelFormatCollection();\n                var innerColl = this.i.labelFormats;\n                if (!innerColl) {\n                    innerColl = new TimeAxisLabelFormatCollection_internal();\n                }\n                this._labelFormats = coll._fromInner(innerColl);\n            }\n            return this._labelFormats;\n        },\n        set: function (v) {\n            if (this._labelFormats !== null) {\n                this._labelFormats._setSyncTarget(null);\n                this._labelFormats = null;\n            }\n            var coll = new IgrTimeAxisLabelFormatCollection();\n            this._labelFormats = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisLabelFormat.$type);\n            var innerColl = this.i.labelFormats;\n            if (!innerColl) {\n                innerColl = new TimeAxisLabelFormatCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._labelFormats._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"intervals\", {\n        /**\n         * A list of axis label intervals to apply, which are selected according to the visible axis range.\n         * The interval selected will be the one with the largest range smaller than the visible range of the axis.\n        */\n        get: function () {\n            if (this._intervals === null) {\n                var coll = new IgrTimeAxisIntervalCollection();\n                var innerColl = this.i.intervals;\n                if (!innerColl) {\n                    innerColl = new TimeAxisIntervalCollection_internal();\n                }\n                this._intervals = coll._fromInner(innerColl);\n            }\n            return this._intervals;\n        },\n        set: function (v) {\n            if (this._intervals !== null) {\n                this._intervals._setSyncTarget(null);\n                this._intervals = null;\n            }\n            var coll = new IgrTimeAxisIntervalCollection();\n            this._intervals = coll._fromOuter(v);\n            var syncColl = new SyncableObservableCollection$1(TimeAxisInterval.$type);\n            var innerColl = this.i.intervals;\n            if (!innerColl) {\n                innerColl = new TimeAxisIntervalCollection_internal();\n            }\n            syncColl._inner = innerColl;\n            syncColl.clear();\n            this._intervals._setSyncTarget(syncColl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IgrTimeXAxis.prototype, \"isCategoryDateTime\", {\n        /**\n         * Gets if the current axis is of category date time axis type\n        */\n        get: function () {\n            return this.i.b7;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IgrTimeXAxis.prototype.findByName = function (name) {\n        var baseResult = _super.prototype.findByName.call(this, name);\n        if (baseResult) {\n            return baseResult;\n        }\n        if (this.breaks != null && this.breaks.findByName && this.breaks.findByName(name)) {\n            return this.breaks.findByName(name);\n        }\n        if (this.labelFormats != null && this.labelFormats.findByName && this.labelFormats.findByName(name)) {\n            return this.labelFormats.findByName(name);\n        }\n        if (this.intervals != null && this.intervals.findByName && this.intervals.findByName(name)) {\n            return this.intervals.findByName(name);\n        }\n        return null;\n    };\n    IgrTimeXAxis.prototype.getValueLabel = function (value) {\n        var iv = this.i.fw(value);\n        return (iv);\n    };\n    /**\n     * Gets the index of the data item with the value nearest the given value.\n    \r\n    * @param unscaledValue  * The value to find a value close to.\n    */\n    IgrTimeXAxis.prototype.getIndexClosestToUnscaledValue = function (unscaledValue) {\n        var iv = this.i.i$f(unscaledValue);\n        return (iv);\n    };\n    return IgrTimeXAxis;\n}(IgrTimeAxisBase));\nexport { IgrTimeXAxis };\n//# sourceMappingURL=igr-time-x-axis.js.map\n"]},"metadata":{},"sourceType":"module"}