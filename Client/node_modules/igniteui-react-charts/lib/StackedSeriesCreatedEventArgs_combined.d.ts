import { EventArgs, Base, Type, Point, IList$1, IEnumerable, IEnumerator$1, IEnumerator, INotifyPropertyChanged, PropertyChangedEventArgs } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { DataTemplate } from "igniteui-react-core";
import { Visibility } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { PenLineCap } from "igniteui-react-core";
import { Style } from "igniteui-react-core";
import { MarkerType } from "./MarkerType";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { CategoryLineRasterizer } from "./CategoryLineRasterizer";
import { Series } from "./Series";
import { List$1 } from "igniteui-react-core";
import { AnchoredCategorySeries } from "./AnchoredCategorySeries";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { CategorySeries } from "./CategorySeries";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { NumericAxisBase } from "./NumericAxisBase";
import { ISupportsMarkers } from "./ISupportsMarkers";
import { CategoryFrame } from "./CategoryFrame";
import { IDetectsCollisions } from "./IDetectsCollisions";
import { Rect } from "igniteui-react-core";
import { CategorySeriesView } from "./CategorySeriesView";
import { SeriesView } from "./SeriesView";
import { Axis } from "./Axis";
import { SeriesViewer } from "./SeriesViewer";
import { PointCollection } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { IFastItemColumn$1 } from "igniteui-react-core";
import { AxisRange } from "./AxisRange";
import { IChartLegend } from "igniteui-react-core";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { RenderSurface } from "./RenderSurface";
import { Path } from "igniteui-react-core";
import { CategoryMode } from "./CategoryMode";
import { DependencyObject } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { Pool$1 } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { IScaler } from "./IScaler";
import { IIsCategoryBased } from "./IIsCategoryBased";
import { NumericXAxis } from "./NumericXAxis";
import { CategoryYAxis } from "./CategoryYAxis";
import { AnchoredCategoryBucketCalculator } from "./AnchoredCategoryBucketCalculator";
import { SplineSeriesBase } from "./SplineSeriesBase";
import { CollisionAvoider } from "./CollisionAvoider";
import { ICategoryScaler } from "./ICategoryScaler";
import { IBucketizer } from "./IBucketizer";
import { FastItemsSourceEventAction } from "igniteui-react-core";
import { IBarSeries } from "./IBarSeries";
import { Color } from "igniteui-react-core";
import { LegendItemBadgeShape } from "./LegendItemBadgeShape";
import { LegendItemBadgeMode } from "./LegendItemBadgeMode";
import { SeriesOutlineMode } from "./SeriesOutlineMode";
import { DomRenderer } from "igniteui-react-core";
import { PropertyUpdatedEventArgs } from "igniteui-react-core";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { IProvidesViewport } from "./IProvidesViewport";
import { ISupportsErrorBars } from "./ISupportsErrorBars";
import { ValuesHolder } from "./ValuesHolder";
import { PreparationParams } from "./PreparationParams";
import { RenderingContext } from "igniteui-react-core";
import { SplineSeriesBaseView } from "./SplineSeriesBaseView";
import { Canvas } from "igniteui-react-core";
import { Panel } from "igniteui-react-core";
/**
 * @hidden
 */
export declare class StackedSeriesCreatedEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: StackedFragmentSeries);
    c: StackedFragmentSeries;
    get brush(): Brush;
    set brush(a: Brush);
    get legendItemTemplate(): DataTemplate;
    set legendItemTemplate(a: DataTemplate);
    get legendItemBadgeTemplate(): DataTemplate;
    set legendItemBadgeTemplate(a: DataTemplate);
    get legendItemVisibility(): Visibility;
    set legendItemVisibility(a: Visibility);
    get outline(): Brush;
    set outline(a: Brush);
    get dashArray(): DoubleCollection;
    set dashArray(a: DoubleCollection);
    get dashCap(): PenLineCap;
    set dashCap(a: PenLineCap);
    get index(): number;
    get thickness(): number;
    set thickness(a: number);
    get title(): any;
    set title(a: any);
    get markerBrush(): Brush;
    set markerBrush(a: Brush);
    get markerOutline(): Brush;
    set markerOutline(a: Brush);
    get markerStyle(): Style;
    set markerStyle(a: Style);
    get markerTemplate(): DataTemplate;
    set markerTemplate(a: DataTemplate);
    get markerType(): MarkerType;
    set markerType(a: MarkerType);
    get markerThickness(): number;
    set markerThickness(a: number);
    get startCap(): PenLineCap;
    set startCap(a: PenLineCap);
    get endCap(): PenLineCap;
    set endCap(a: PenLineCap);
}
/**
 * @hidden
 */
export declare abstract class FragmentBase extends HorizontalAnchoredCategorySeries {
    static $t: Type;
    constructor();
    ug: CategoryLineRasterizer;
    private _logicalSeriesLink;
    get logicalSeriesLink(): StackedFragmentSeries;
    set logicalSeriesLink(a: StackedFragmentSeries);
    private ui;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    protected get_dh(): boolean;
    protected get_dn(): boolean;
    i9(): string;
    gz(): number;
    g3(): number;
    resolveLegendIndex(): number;
    be(): Series;
    q2(): CategoryAxisBase;
    uf(): CategoryFramePreparer;
    rn(): NumericAxisBase;
    uk(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    si(a: CategoryFrame, b: CategorySeriesView): void;
    o2(a: Point, b: boolean, c: boolean): Point;
    ag(): Axis[];
    private ul;
    un(a: PointCollection, b: List$1<number[]>, c: CategorySeriesView): void;
    e3(a: Rect, b: Rect, c: SeriesView): boolean;
    s4(a: CategorySeriesView): number;
    ap(a: Axis): AxisRange;
    um(): number;
    uo(a: IChartLegend): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    l2(a: Rect, b: RenderSurface): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragment extends FragmentBase {
    static $t: Type;
    constructor();
    protected bu(): SeriesView;
    up: AreaFragmentView;
    lh(a: SeriesView): void;
    protected get_c8(): boolean;
    protected get_c7(): boolean;
    protected ur(a: Point, b: boolean): boolean;
    ep(a: Point, b: boolean): boolean;
    private uq;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    kh(a: boolean, b: SeriesView): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    ma(): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class ColumnFragment extends FragmentBase {
    static $t: Type;
    protected get_db(): boolean;
    protected get_dw(): boolean;
    constructor();
    protected bu(): SeriesView;
    uq: ColumnFragmentView;
    lh(a: SeriesView): void;
    ut: number;
    uu: number;
    get fragmentXAxis(): CategoryAxisBase;
    get fragmentYAxis(): NumericAxisBase;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    q2(): CategoryAxisBase;
    rn(): NumericAxisBase;
    protected get_cy(): boolean;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    kh(a: boolean, b: SeriesView): void;
    ap(a: Axis): AxisRange;
    e3(a: Rect, b: Rect, c: SeriesView): boolean;
    e0(): boolean;
    r3(a: SeriesView): number;
    r4(a: SeriesView): number;
    r5(a: SeriesView): number;
    pb(a: Point): Rect;
    ep(a: Point, b: boolean): boolean;
    protected es(a: Point, b: boolean): boolean;
    protected uz(a: Rect, b: number): Rect;
    hn(a: any, b: Point): any;
    hh(a: Point): any;
    g2(a: Point): number;
    g0(a: Point): number;
    uk(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    private us;
    lz(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    si(a: CategoryFrame, b: CategorySeriesView): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class BarFragment extends ColumnFragment {
    static $t: Type;
    constructor();
    protected get_c9(): boolean;
    protected get_dw(): boolean;
    protected get_db(): boolean;
    get barFragmentXAxis(): NumericXAxis;
    get barFragmentYAxis(): CategoryYAxis;
    q2(): CategoryAxisBase;
    protected get_isVertical(): boolean;
    fw(a: Point): number;
    rn(): NumericAxisBase;
    protected uz(a: Rect, b: number): Rect;
    pb(a: Point): Rect;
    ep(a: Point, b: boolean): boolean;
    uk(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    hh(a: Point): any;
    g2(a: Point): number;
    s4(a: CategorySeriesView): number;
    protected lm(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucketWithoutUnknowns(a: number): number[];
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class LineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucketWithoutUnknowns(a: number): number[];
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class SplineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class StackedBucketCalculator extends CategoryBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class StackedBarBucketCalculator extends StackedBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    g(a: number): void;
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class StackedColumnBucketCalculator extends StackedBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class FragmentBaseValueList extends Base implements IList$1<number> {
    static $t: Type;
    private a;
    constructor(a: FragmentBase);
    indexOf(a: number): number;
    insert(a: number, b: number): void;
    removeAt(a: number): void;
    item(a: number, b?: number): number;
    add(a: number): void;
    clear(): void;
    contains(a: number): boolean;
    copyTo(a: number[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: number): boolean;
    getEnumerator(): IEnumerator$1<number>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class LineFragment extends FragmentBase {
    static $t: Type;
    protected get_dv(): boolean;
    constructor();
    protected bu(): SeriesView;
    up: LineFragmentView;
    lh(a: SeriesView): void;
    protected ur(a: Point, b: boolean): boolean;
    protected get_c8(): boolean;
    ep(a: Point, b: boolean): boolean;
    private uq;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    kh(a: boolean, b: SeriesView): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare abstract class SplineFragmentBase extends SplineSeriesBase {
    static $t: Type;
    private _logicalSeriesLink;
    get logicalSeriesLink(): StackedFragmentSeries;
    set logicalSeriesLink(a: StackedFragmentSeries);
    uz: CategoryLineRasterizer;
    constructor();
    private u1;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    protected get_dh(): boolean;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    protected get_dn(): boolean;
    i9(): string;
    o2(a: Point, b: boolean, c: boolean): Point;
    ag(): Axis[];
    private u3;
    gz(): number;
    resolveLegendIndex(): number;
    g3(): number;
    be(): Series;
    ul(a: CategoryFrame, b: number[], c: CollisionAvoider, d: number, e: number, f: CategorySeriesView, g: number): boolean;
    e3(a: Rect, b: Rect, c: SeriesView): boolean;
    ap(a: Axis): AxisRange;
    u4(a: CategoryFrame, b: Rect, c: Rect, d: CategoryAxisBase, e: NumericYAxis, f: CategorySeriesView): void;
    si(a: CategoryFrame, b: CategorySeriesView): void;
    uf(a: CategorySeriesView): number[][];
    ug(a: CategorySeriesView): number[][];
    uu(a: CategorySeriesView): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineAreaFragment extends SplineFragmentBase {
    static $t: Type;
    constructor();
    protected bu(): SeriesView;
    lh(a: SeriesView): void;
    private u5;
    ac(): void;
    protected get_c8(): boolean;
    protected get_c7(): boolean;
    protected get_ea(): boolean;
    protected u7(a: Point, b: boolean): boolean;
    ep(a: Point, b: boolean): boolean;
    private u6;
    u9: PointCollection;
    kh(a: boolean, b: SeriesView): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    l2(a: Rect, b: RenderSurface): void;
    u8(a: PointCollection, b: List$1<number[]>, c: CategorySeriesView): void;
    s4(a: CategorySeriesView): number;
    ma(): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineFragment extends SplineFragmentBase {
    static $t: Type;
    protected get_ea(): boolean;
    constructor();
    protected bu(): SeriesView;
    u5: SplineFragmentView;
    lh(a: SeriesView): void;
    protected u7(a: Point, b: boolean): boolean;
    protected get_c8(): boolean;
    ep(a: Point, b: boolean): boolean;
    private u6;
    kh(a: boolean, b: SeriesView): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineFragmentBaseValueList extends Base implements IList$1<number> {
    static $t: Type;
    private a;
    constructor(a: SplineFragmentBase);
    indexOf(a: number): number;
    insert(a: number, b: number): void;
    removeAt(a: number): void;
    item(a: number, b?: number): number;
    add(a: number): void;
    clear(): void;
    contains(a: number): boolean;
    copyTo(a: number[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: number): boolean;
    getEnumerator(): IEnumerator$1<number>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class StackedSeriesBase extends CategorySeries implements IIsCategoryBased {
    static $t: Type;
    constructor();
    k2(): void;
    protected get_dr(): boolean;
    getHostReferenceValue(): number;
    protected bu(): SeriesView;
    s1: StackedSeriesView;
    lh(a: SeriesView): void;
    li(a: Rect, b: Rect): void;
    private _series;
    get series(): StackedSeriesCollection;
    set series(a: StackedSeriesCollection);
    g8(): number;
    ku(a: (arg1: Series) => boolean): void;
    s2: boolean;
    s4: boolean;
    protected get_isStacked(): boolean;
    seriesCreated: (sender: any, e: StackedSeriesCreatedEventArgs) => void;
    tr: Visibility;
    ta: number;
    s9: number;
    ss: number[];
    st: number[];
    s0: StackedSeriesManager;
    sx: StackedSeriesCollection;
    get sw(): StackedSeriesCollection;
    private tg;
    private tm;
    private tl;
    l7(a: Point): void;
    q9(a: CategorySeriesView): CategoryFramePreparer;
    si(a: CategoryFrame, b: CategorySeriesView): void;
    kh(a: boolean, b: SeriesView): void;
    th(): void;
    tn(): void;
    protected get_s3(): boolean;
    get s3(): boolean;
    eh(a: any): boolean;
    ap(a: Axis): AxisRange;
    pt(): boolean;
    protected kk(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    sv(): CategorySeriesView;
    s7(): number;
    s8(): number;
    tc(a: StackedFragmentSeries): number;
    tb(a: Point): number;
    s5(a: AnchoredCategorySeries, b: Rect, c: Rect, d: SeriesView): boolean;
    private s6;
    ti(): void;
    sl(a: CategoryFrame, b: CategorySeriesView): void;
    tk(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView): void;
    protected tj(): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    get currentCategoryMode(): CategoryMode;
    get scaler(): ICategoryScaler;
    get yScaler(): IScaler;
    get bucketizer(): IBucketizer;
    get currentMode2Index(): number;
    provideCollisionDetector(): IDetectsCollisions;
    protected ek(): boolean;
    protected get_dh(): boolean;
    l2(a: Rect, b: RenderSurface): void;
    su: CategoryFrame;
    lz(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    hg(): any;
    get mayContainUnknowns(): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class HorizontalStackedSeriesBase extends StackedSeriesBase {
    static $t: Type;
    xAxis: CategoryAxisBase;
    yAxis: NumericYAxis;
    getOffsetValue(): number;
    getCategoryWidth(): number;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    ag(): Axis[];
    rx(): boolean;
    ma(): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    tv(a: any): boolean;
    tu(a: any): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedAreaSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected get_c7(): boolean;
    constructor();
    ac(): void;
    protected bu(): SeriesView;
    t0: StackedAreaSeriesView;
    lh(a: SeriesView): void;
    ap(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare abstract class VerticalStackedSeriesBase extends StackedSeriesBase {
    static $t: Type;
    xAxis: NumericXAxis;
    yAxis: CategoryYAxis;
    q2(): CategoryAxisBase;
    rn(): NumericAxisBase;
    getOffsetValue(): number;
    getCategoryWidth(): number;
    protected get_isVertical(): boolean;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    rx(): boolean;
    protected lm(a: any, b: string, c: any, d: any): void;
    tv(a: any): boolean;
    tu(a: any): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedBarSeries extends VerticalStackedSeriesBase implements IBarSeries {
    static $t: Type;
    protected get_c9(): boolean;
    protected get_dw(): boolean;
    constructor();
    ac(): void;
    protected bu(): SeriesView;
    t0: StackedBarSeriesView;
    lh(a: SeriesView): void;
    t1: number;
    t2: number;
    sv(): CategorySeriesView;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    r6(): number;
    s7(): number;
    s8(): number;
    ap(a: Axis): AxisRange;
    eh(a: any): boolean;
    e3(a: Rect, b: Rect, c: SeriesView): boolean;
    protected kk(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    g0(a: Point): number;
    hh(a: Point): any;
    tn(): void;
    tb(a: Point): number;
    s5(a: AnchoredCategorySeries, b: Rect, c: Rect, d: SeriesView): boolean;
    f1(): number;
    tk(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    getPreferredCategoryMode(): CategoryMode;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedColumnSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected get_db(): boolean;
    protected get_dw(): boolean;
    constructor();
    protected bu(): SeriesView;
    t0: StackedColumnSeriesView;
    lh(a: SeriesView): void;
    t1: number;
    t2: number;
    sv(): CategorySeriesView;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    ap(a: Axis): AxisRange;
    f1(): number;
    tk(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSplineAreaSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    t1: boolean;
    protected get_c7(): boolean;
    protected get_ea(): boolean;
    constructor();
    ac(): void;
    protected bu(): SeriesView;
    t0: StackedSplineAreaSeriesView;
    lh(a: SeriesView): void;
    ap(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    protected lm(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSplineSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    t1: boolean;
    protected get_ea(): boolean;
    constructor();
    ac(): void;
    protected bu(): SeriesView;
    t0: StackedSplineSeriesView;
    lh(a: SeriesView): void;
    ap(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedFragmentSeries extends DependencyObject implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    itemsSource: IEnumerable;
    hx: Brush;
    hs: Brush;
    h6: DoubleCollection;
    h5: DoubleCollection;
    ia: PenLineCap;
    h7: PenLineCap;
    ag: boolean;
    private y;
    aa: boolean;
    bi: number;
    az: number;
    h4: Color;
    h3: Color;
    an: boolean;
    private z;
    ae: boolean;
    bj: number;
    a0: number;
    bk: number;
    a1: number;
    ib: PenLineCap;
    h8: PenLineCap;
    ah: boolean;
    ab: boolean;
    fi: DataTemplate;
    ff: DataTemplate;
    fj: DataTemplate;
    fg: DataTemplate;
    iw: Visibility;
    iu: Visibility;
    p: LegendItemBadgeShape;
    n: LegendItemBadgeMode;
    o: LegendItemBadgeShape;
    m: LegendItemBadgeMode;
    hy: Brush;
    ht: Brush;
    hz: Brush;
    hu: Brush;
    it: Style;
    is: Style;
    fk: DataTemplate;
    fh: DataTemplate;
    r: MarkerType;
    q: MarkerType;
    dk: string;
    bf: number;
    aw: number;
    h0: Brush;
    hv: Brush;
    h1: Brush;
    hw: Brush;
    a3: number;
    as: number;
    bd: number;
    au: number;
    u: SeriesOutlineMode;
    t: SeriesOutlineMode;
    bc: number;
    at: number;
    bg: number;
    ax: number;
    ac: boolean;
    ai: boolean;
    bh: number;
    ay: number;
    ic: PenLineCap;
    h9: PenLineCap;
    bl: number;
    a2: number;
    be: number;
    av: number;
    bv: any;
    bw: any;
    bs: any;
    am: boolean;
    ad: boolean;
    d4: string;
    ix: Visibility;
    iv: Visibility;
    private _parentSeries;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    br: number;
    w: SeriesViewer;
    x: IFastItemColumn$1<number>;
    private _visualSeriesLink;
    get visualSeriesLink(): AnchoredCategorySeries;
    set visualSeriesLink(a: AnchoredCategorySeries);
    ap: List$1<number>;
    aq: List$1<number>;
    ao: List$1<number[]>;
    aj: boolean;
    bn(a: Point): number;
    bt(a: Point): any;
    bq(a: Point, b: boolean): number;
    bp(a: Point, b: boolean): number;
    ba(a: Point, b: boolean, c: boolean): number;
    ij(a: Point, b: boolean, c: boolean): Point;
    io(a: Point): Rect;
    j(a: Point): Rect[];
    ip(a: Point): Rect;
    k(a: Point): Rect[];
    iq(a: Point): Rect;
    ir(a: Point): Rect;
    a6(a: Point, b: boolean, c: boolean): number;
    ie(a: Point, b: boolean, c: boolean): Point;
    a8(a: Point, b: boolean, c: boolean): number;
    ih(a: Point, b: boolean, c: boolean): Point;
    ik(a: Point, b: boolean, c: boolean): Point;
    bb(a: Point, b: boolean, c: boolean): number;
    ig(a: Point, b: boolean, c: boolean): Point;
    a7(a: Point, b: boolean, c: boolean): number;
    ii(a: Point, b: boolean, c: boolean): Point;
    a9(a: Point, b: boolean, c: boolean): number;
    bo(a: Point): number;
    a5(): number;
    a4(a: Point): number;
    bu(a: Point): any;
    af(a: List$1<SeriesPointOfInterest>, b: boolean, c: number): boolean;
    il(a: Point): Point;
    id(a: Point): Point;
    ak(a: any): boolean;
    im(): Rect;
    d8(): void;
    ec(a: Point): void;
    al(a: Point, b: boolean): boolean;
    d7(a: Point): void;
    bm: DomRenderer;
    provideRenderer(a: DomRenderer): void;
    h2: Brush;
    fe(): void;
    ew(): void;
    ey(): void;
    ee(): void;
    ef(): void;
    ei(): void;
    e2(): void;
    et(): void;
    eg(): void;
    ej(): void;
    e5(): void;
    e6(): void;
    fd(): void;
    e7(): void;
    e8(): void;
    eh(): void;
    ek(): void;
    ep(): void;
    eq(): void;
    er(): void;
    eo(): void;
    en(): void;
    es(): void;
    eu(): void;
    ev(): void;
    ez(): void;
    e0(): void;
    e1(): void;
    em(): void;
    ed(): void;
    el(): void;
    e3(): void;
    e4(): void;
    e9(): void;
    fa(): void;
    ex(): void;
    fb(): void;
    fc(): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected eb(a: string, b: any, c: any): void;
    protected d9(a: any, b: string, c: any, d: any): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSeriesCollection extends ObservableCollection$1<StackedFragmentSeries> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class StackedSeriesFramePreparer extends CategoryFramePreparer {
    static $t: Type;
    constructor(a: number, b: IIsCategoryBased);
    constructor(a: number, b: IIsCategoryBased, c: ISupportsMarkers, d: IProvidesViewport, e: ISupportsErrorBars, f: IBucketizer);
    constructor(a: number, ..._rest: any[]);
    protected j(a: PreparationParams): ValuesHolder;
    protected t(a: PreparationParams, b: ValuesHolder, c: number, d: boolean, e: boolean): number;
    protected l(a: CategoryFrame, b: number[], c: IDetectsCollisions, d: number, e: number, f: number): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    da: AreaFragment;
    as(): void;
    constructor(a: AreaFragment);
    dg: Path;
    di: Path;
    dh: Path;
    dj: Path;
    dc: Path;
    de: Path;
    dd: Path;
    df: Path;
    db(): void;
    cs(): CategoryBucketCalculator;
    protected bb(): void;
    protected bc(): void;
    protected a6(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    al(a: any): void;
}
/**
 * @hidden
 */
export declare class ColumnFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    da: ColumnFragment;
    as(): void;
    constructor(a: ColumnFragment);
    protected de: List$1<Rectangle>;
    db: Pool$1<Rectangle>;
    dc: List$1<number>;
    dd: List$1<number>;
    private dk;
    private df;
    private dh;
    private dg;
    protected be(a: any, b: number): void;
    di(a: Rectangle, b: number, c: number): void;
    protected bf(a: any, b: number): void;
    protected ac(a: number): any;
    private dj;
    protected ab(a: number): any;
    protected a6(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    al(a: any): void;
    getDefaultTooltipTemplate(): string;
}
/**
 * @hidden
 */
export declare class LineFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    da: LineFragment;
    constructor(a: LineFragment);
    dg: Path;
    df: Path;
    dh: Path;
    dd: Path;
    dc: Path;
    de: Path;
    db(): void;
    cs(): CategoryBucketCalculator;
    protected bb(): void;
    protected bc(): void;
    protected a6(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    al(a: any): void;
}
/**
 * @hidden
 */
export declare class SplineAreaFragmentView extends SplineSeriesBaseView {
    static $t: Type;
    private db;
    as(): void;
    constructor(a: SplineAreaFragment);
    dh: Path;
    dj: Path;
    di: Path;
    dk: Path;
    dd: Path;
    df: Path;
    de: Path;
    dg: Path;
    dc(): void;
    protected bb(): void;
    protected bc(): void;
    protected a6(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    al(a: any): void;
}
/**
 * @hidden
 */
export declare class SplineFragmentView extends SplineSeriesBaseView {
    static $t: Type;
    db: SplineFragment;
    constructor(a: SplineFragment);
    cs(): CategoryBucketCalculator;
    dh: Path;
    dg: Path;
    di: Path;
    de: Path;
    dd: Path;
    df: Path;
    dc(): void;
    protected bb(): void;
    protected bc(): void;
    protected a6(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    al(a: any): void;
}
/**
 * @hidden
 */
export declare class StackedSeriesView extends CategorySeriesView {
    static $t: Type;
    c0: StackedSeriesBase;
    private readonly c1;
    get c2(): Canvas;
    private readonly c3;
    get c4(): Panel;
    constructor(a: StackedSeriesBase);
    cs(): CategoryBucketCalculator;
    ap(): void;
    ar(a: RenderingContext, b: RenderingContext): void;
    protected af(): void;
}
/**
 * @hidden
 */
export declare class StackedBarSeriesView extends StackedSeriesView {
    static $t: Type;
    c5: StackedBarSeries;
    constructor(a: StackedBarSeries);
    cs(): CategoryBucketCalculator;
    as(): void;
}
/**
 * @hidden
 */
export declare class StackedColumnSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedColumnSeries);
    cs(): CategoryBucketCalculator;
    as(): void;
}
/**
 * @hidden
 */
export declare class StackedAreaSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedAreaSeries);
    as(): void;
}
/**
 * @hidden
 */
export declare class StackedSplineAreaSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedSplineAreaSeries);
    as(): void;
}
/**
 * @hidden
 */
export declare class StackedSplineSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedSplineSeries);
    as(): void;
}
/**
 * @hidden
 */
export declare class StackedSeriesManager extends Base {
    static $t: Type;
    constructor(a: StackedSeriesBase);
    b: StackedSeriesBase;
    f: ObservableCollection$1<AnchoredCategorySeries>;
    c: StackedSeriesCollection;
    e: ObservableCollection$1<AnchoredCategorySeries>;
    d: ObservableCollection$1<AnchoredCategorySeries>;
    j: Canvas;
    k: Panel;
    a(a: StackedFragmentSeries): AnchoredCategorySeries;
    private i;
    h(): void;
    private g;
}
