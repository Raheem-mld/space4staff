import { Control } from "igniteui-react-core";
import { INotifyPropertyChanged, Type, Base, Point, EventArgs, PropertyChangedEventArgs, IEnumerable, IEnumerable$1, IList$1 } from "igniteui-react-core";
import { ILegendOwner } from "igniteui-react-core";
import { IInternalLegendOwner } from "igniteui-react-core";
import { ISeriesViewerWidget } from "./ISeriesViewerWidget";
import { SRProvider } from "igniteui-react-core";
import { DoubleAnimator } from "igniteui-react-core";
import { BrushCollection } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { DependencyObject } from "igniteui-react-core";
import { MarkerAutomaticBehavior } from "./MarkerAutomaticBehavior";
import { IChartLegend } from "igniteui-react-core";
import { SeriesHighlightingMode } from "./SeriesHighlightingMode";
import { SeriesHighlightingBehavior } from "./SeriesHighlightingBehavior";
import { LegendHighlightingMode } from "./LegendHighlightingMode";
import { LegendItemBadgeShape } from "./LegendItemBadgeShape";
import { LegendItemBadgeMode } from "./LegendItemBadgeMode";
import { Rect } from "igniteui-react-core";
import { ChartHitTestMode } from "./ChartHitTestMode";
import { InteractionState } from "igniteui-react-core";
import { WindowResponse } from "./WindowResponse";
import { Visibility } from "igniteui-react-core";
import { IOverviewPlusDetailPane } from "igniteui-react-core";
import { SeriesViewerComponentsFromView } from "./SeriesViewerComponentsFromView";
import { ZoomCoercionMode } from "./ZoomCoercionMode";
import { Brush } from "igniteui-react-core";
import { ModifierKeys } from "igniteui-react-core";
import { DataTemplate } from "igniteui-react-core";
import { HorizontalAlignment } from "igniteui-react-core";
import { CanvasRenderScheduler } from "igniteui-react-core";
import { SyncSettings } from "./SyncSettings";
import { SeriesViewerComponentsForView } from "./SeriesViewerComponentsForView";
import { Dictionary$2 } from "igniteui-react-core";
import { PropertyUpdatedEventArgs } from "igniteui-react-core";
import { NotifyCollectionChangedEventArgs } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { FrameworkElement } from "igniteui-react-core";
import { EventProxy } from "igniteui-react-core";
import { MouseEventArgs } from "igniteui-react-core";
import { MouseButtonEventArgs } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { SeriesViewerManipulationEventArgs } from "./SeriesViewerManipulationEventArgs";
import { Key } from "igniteui-react-core";
import { CultureInfo } from "igniteui-react-core";
import { RectChangedEventArgs } from "igniteui-react-core";
import { RefreshCompletedEventArgs } from "./RefreshCompletedEventArgs";
import { Thickness } from "igniteui-react-core";
import { AxisTitlePosition } from "./AxisTitlePosition";
import { FontInfo } from "igniteui-react-core";
import { IFastItemsSource } from "igniteui-react-core";
import { CoercionInfo } from "./CoercionInfo";
import { ChartContentType } from "./ChartContentType";
import { ISchedulableRender } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { Line } from "igniteui-react-core";
import { RenderingContext } from "igniteui-react-core";
import { TextBlock } from "igniteui-react-core";
import { ITileZoomTile } from "./ITileZoomTile";
import { IExecutionContext } from "igniteui-react-core";
import { RenderSurface } from "./RenderSurface";
import { PathGeometry } from "igniteui-react-core";
import { Geometry } from "igniteui-react-core";
import { DataContext } from "igniteui-react-core";
import { LabelPanelsArrangeState } from "./LabelPanelsArrangeState";
import { AxisLabelsLocation } from "./AxisLabelsLocation";
import { IProvidesViewport } from "./IProvidesViewport";
import { DomRenderer, DomWrapper } from "igniteui-react-core";
import { PointerTooltipStyle } from "./PointerTooltipStyle";
import { DefaultPaletteInfo } from "./DefaultPaletteInfo";
import { AxisRange } from "./AxisRange";
import { AxisAnnotationCollection } from "./AxisAnnotationCollection";
import { VerticalAlignment } from "igniteui-react-core";
import { Canvas } from "igniteui-react-core";
import { IFastItemsSourceProvider } from "igniteui-react-core";
import { AxisExtentType } from "./AxisExtentType";
import { DoubleCollection } from "igniteui-react-core";
import { LabelPosition } from "./LabelPosition";
import { BindingFormatter } from "igniteui-react-core";
import { LabelFontHeuristics } from "./LabelFontHeuristics";
import { AxisOrientation } from "./AxisOrientation";
import { Pool$1 } from "igniteui-react-core";
import { AxisComponentsFromView } from "./AxisComponentsFromView";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { GeometryCollection } from "igniteui-react-core";
import { PathRenderingInfo } from "./PathRenderingInfo";
import { RenderRequestedEventArgs } from "./RenderRequestedEventArgs";
import { CategoryMode } from "./CategoryMode";
import { GridMode } from "./GridMode";
import { Panel } from "igniteui-react-core";
import { UIElement } from "igniteui-react-core";
import { TickmarkValues } from "./TickmarkValues";
import { ICategoryScaler } from "./ICategoryScaler";
import { FastItemsSourceEventArgs } from "igniteui-react-core";
import { FastItemsSourceEventAction } from "igniteui-react-core";
import { NumericAxisRenderingParameters } from "./NumericAxisRenderingParameters";
import { AxisRenderingParametersBase } from "./AxisRenderingParametersBase";
import { HighlightingState } from "./HighlightingState";
import { Marker } from "./Marker";
import { Polyline } from "igniteui-react-core";
import { ContentControl } from "igniteui-react-core";
import { Polygon } from "igniteui-react-core";
import { ComputedPlotAreaMarginMode } from "./ComputedPlotAreaMarginMode";
import { ILegendSeries } from "igniteui-react-core";
import { ILegendSeriesInternal } from "igniteui-react-core";
import { ILegendTemplateProvider } from "igniteui-react-core";
import { StandardLegendItems } from "igniteui-react-core";
import { PenLineCap } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { SeriesVisibleRangeMode } from "./SeriesVisibleRangeMode";
import { SeriesOutlineMode } from "./SeriesOutlineMode";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { SeriesHitTestMode } from "./SeriesHitTestMode";
import { SeriesComponentsForView } from "./SeriesComponentsForView";
import { MarkerOutlineMode } from "./MarkerOutlineMode";
import { MarkerFillMode } from "./MarkerFillMode";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { SeriesComponentsFromView } from "./SeriesComponentsFromView";
import { IFastItemColumn$1 } from "igniteui-react-core";
import { ISortingAxis } from "./ISortingAxis";
import { ActualLegendItemBadgeShape } from "./ActualLegendItemBadgeShape";
import { MarkerType } from "./MarkerType";
import { Style } from "igniteui-react-core";
import { HashPool$2 } from "igniteui-react-core";
/**
 * @hidden
 */
export declare abstract class SeriesViewer extends Control implements INotifyPropertyChanged, ILegendOwner, IInternalLegendOwner {
    static $t: Type;
    private _widget;
    get widget(): ISeriesViewerWidget;
    set widget(a: ISeriesViewerWidget);
    cf: SeriesViewerView;
    static staticInit(): void;
    private cq;
    private get cr();
    private a4;
    get a5(): ISeriesViewerInteractionManager;
    get dv(): boolean;
    constructor();
    private b7;
    jm(): void;
    private ld;
    jn(): void;
    get series(): SeriesCollection;
    private bk;
    private l6;
    jp(): void;
    protected j5(): void;
    private _skipDataCleanup;
    get skipDataCleanup(): boolean;
    set skipDataCleanup(a: boolean);
    protected l0(a: any): void;
    private l7;
    js(a: number, b: number, c: boolean, d: boolean): {
        p0?: number;
        p1?: number;
    };
    di(): boolean;
    get ek(): boolean;
    protected get dr(): boolean;
    get a3(): IHighlightingManager;
    private jg;
    cg: DoubleAnimator;
    private jl;
    mk(a: number): void;
    jk(): void;
    ou(a: number): Brush;
    o0(a: number): Brush;
    oy(a: number): Brush;
    oz(a: number): Brush;
    private ot;
    ag: BrushCollection;
    aj: BrushCollection;
    ah: BrushCollection;
    ai: BrushCollection;
    a9: MarkerAutomaticBehavior;
    ap: ChartContentManager;
    get o8(): Point;
    set o8(a: Point);
    private o7;
    get du(): boolean;
    get legend(): IChartLegend;
    set legend(a: IChartLegend);
    static readonly no: DependencyProperty;
    get da(): boolean;
    set da(a: boolean);
    plotAreaMouseLeftButtonDown: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaMouseLeftButtonUp: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaClicked: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaMouseEnter: (sender: any, e: PlotAreaMouseEventArgs) => void;
    plotAreaMouseLeave: (sender: any, e: PlotAreaMouseEventArgs) => void;
    plotAreaMouseOver: (sender: any, e: PlotAreaMouseEventArgs) => void;
    ku(a: Point, b: boolean): void;
    private ba;
    private be;
    kv(a: Point, b: boolean, c: boolean): void;
    static readonly m6: DependencyProperty;
    get d2(): boolean;
    set d2(a: boolean);
    static readonly nk: DependencyProperty;
    get ej(): boolean;
    set ej(a: boolean);
    static readonly n5: DependencyProperty;
    get bq(): SeriesHighlightingMode;
    set bq(a: SeriesHighlightingMode);
    static readonly ng: DependencyProperty;
    private bp;
    private bm;
    get bn(): SeriesHighlightingBehavior;
    get bo(): SeriesHighlightingBehavior;
    set bo(a: SeriesHighlightingBehavior);
    static readonly nf: DependencyProperty;
    get a6(): LegendHighlightingMode;
    set a6(a: LegendHighlightingMode);
    static readonly nl: DependencyProperty;
    get a8(): LegendItemBadgeShape;
    set a8(a: LegendItemBadgeShape);
    static readonly nn: DependencyProperty;
    get a7(): LegendItemBadgeMode;
    set a7(a: LegendItemBadgeMode);
    static readonly nm: DependencyProperty;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected ll(a: string, b: any, c: any): void;
    kl(): void;
    km(a: IEnumerable): void;
    kx(a: Series, b: any, c: any): void;
    k1(a: Series, b: any, c: any): void;
    ky(a: Series, b: any, c: any): void;
    kz(a: Series, b: any, c: any): void;
    k0(a: Series, b: any, c: any): void;
    i1(a: Rect, b: ScalerParams): Tuple$2<boolean, number>;
    get d8(): boolean;
    private c0;
    j4(): void;
    k2(a: Series, b: any, c: any): void;
    k3(a: Series, b: any, c: any): void;
    seriesCursorMouseMove: (sender: any, e: ChartCursorEventArgs) => void;
    lo(a: Series, b: any): void;
    seriesMouseLeftButtonDown: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    ls(a: Series, b: any, c: MouseButtonEventArgs): void;
    seriesMouseLeftButtonUp: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    lt(a: Series, b: any, c: MouseButtonEventArgs): void;
    seriesMouseMove: (sender: any, e: ChartMouseEventArgs) => void;
    mb(a: Point): void;
    mc(a: Point): void;
    lu(a: Series, b: any, c: MouseEventArgs): void;
    seriesMouseEnter: (sender: any, e: ChartMouseEventArgs) => void;
    lq(a: Series, b: any, c: MouseEventArgs): void;
    seriesMouseLeave: (sender: any, e: ChartMouseEventArgs) => void;
    lr(a: Series, b: any, c: MouseEventArgs): void;
    private cv;
    j3(): void;
    private pf;
    protected get_pv(): Rect;
    get pv(): Rect;
    private pd;
    get pk(): Rect;
    set pk(a: Rect);
    pp(a: Rect, b: Rect, c: Rect): Rect;
    private ct;
    private pc;
    protected get_pj(): Rect;
    get pj(): Rect;
    pn(a: Rect, b: Rect, c: Rect): Rect;
    protected pi(a: Rect): Rect;
    po(): Rect;
    protected mg(a: Axis): void;
    pw: Rect;
    er: boolean;
    c8: boolean;
    ef: boolean;
    ge: number;
    private f7;
    get ga(): number;
    set ga(a: number);
    gd: number;
    protected d9: boolean;
    lg(a: Rect, b: Rect): void;
    private br;
    bs(): SeriesViewerComponentsForView;
    private cy;
    i7(a: Point, b: boolean): void;
    dy: boolean;
    private ar;
    get at(): ChartHitTestMode;
    set at(a: ChartHitTestMode);
    lw(): void;
    protected au(): ChartHitTestMode;
    private aq;
    get as(): ChartHitTestMode;
    set as(a: ChartHitTestMode);
    dz: boolean;
    seriesAnimating: (series: Series) => void;
    ln(a: Series): void;
    abstract d4(): boolean;
    abstract d5(): boolean;
    d3(): boolean;
    onDetachedFromUI(): void;
    onAttachedToUI(): void;
    get b6(): InteractionState;
    set b6(a: InteractionState);
    private cw;
    private b2;
    ko(a: Point): void;
    kp(a: Point, b: boolean): void;
    ed(a: Point, b: number): boolean;
    ke(a: Point): void;
    ec(a: Key): boolean;
    private c2;
    de: boolean;
    private cu;
    get db(): boolean;
    set db(a: boolean);
    protected get_dw(): boolean;
    get dw(): boolean;
    kg(a: Point): void;
    get dh(): boolean;
    iq: string;
    kt(a: Point): void;
    kh(a: Point, b: boolean): void;
    kf(a: Point): void;
    get ee(): boolean;
    set ee(a: boolean);
    private lb;
    ks(a: Point): void;
    lc(a: Point, b: number, c: number, d: number): void;
    kr(a: number): void;
    k8(a: Point, b: number, c: number, d: number): void;
    kn(a: Point): void;
    kq(a: number): void;
    ki(a: Point): void;
    k7(a: Point, b: number, c: number, d: number): void;
    kk(a: Size): void;
    jj(): void;
    j8(a: Point, b: boolean): void;
    b4(a: boolean): InteractionState;
    viewerManipulationStarting: (sender: any, e: SeriesViewerManipulationEventArgs) => void;
    viewerManipulationEnding: (sender: any, e: SeriesViewerManipulationEventArgs) => void;
    private c6;
    la(): void;
    k9(): void;
    md(): void;
    je(): void;
    i9(): void;
    i8(): void;
    le(): void;
    lz(): void;
    lx(): void;
    j7(a: Point, b: boolean): void;
    ei(): boolean;
    private c3;
    get em(): boolean;
    set em(a: boolean);
    j6(a: Point, b: boolean, c: boolean): void;
    mq(a: any, b: PropertyUpdatedEventArgs): void;
    mp(a: SyncLink, b: SyncLink): void;
    ja(a: Point): void;
    ms(a: Rect, b: boolean): void;
    mt(a: Rect, b: boolean, c: boolean): void;
    lf(a: Rect, b: boolean): void;
    get d0(): boolean;
    private _eu;
    eu(): IEnumerable$1<SeriesViewer>;
    pa(a: Point): Point;
    pu(a: Rect): Rect;
    windowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private lv;
    k6(a: Rect, b: Rect): void;
    sizeChanged: (sender: any, e: RectChangedEventArgs) => void;
    k4(a: Size, b: Size): void;
    dl: boolean;
    eg(a: Rect, b: Rect): boolean;
    actualWindowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private lj;
    l5(): void;
    gridAreaRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private lk;
    protected get_dx(): boolean;
    get dx(): boolean;
    kw(a: Rect, b: Rect): void;
    bw: WindowResponse;
    jr(): void;
    dg: boolean;
    f5: number;
    private _syncChannel;
    get syncChannel(): string;
    set syncChannel(a: string);
    private bt;
    get actualSyncLink(): SyncLink;
    set actualSyncLink(a: SyncLink);
    en: boolean;
    jq(): void;
    p1: Visibility;
    private c5;
    kc(): void;
    ka(): void;
    kb(): void;
    get b8(): IOverviewPlusDetailPane;
    protected mm(a: boolean): void;
    p0: Visibility;
    dk: boolean;
    eq: boolean;
    private bx;
    get by(): ZoomCoercionMode;
    set by(a: ZoomCoercionMode);
    bz(): ZoomCoercionMode;
    b0: ZoomCoercionMode;
    o2: Brush;
    or: Brush;
    o1: Brush;
    dd(): boolean;
    c9(): boolean;
    px: Rect;
    i6(): void;
    private f9;
    private notifyCrosshairUpdate;
    protected mr(a: number, b: number): void;
    fn(): number;
    fo(): number;
    protected lh(a: any, b: string, c: any, d: any): void;
    get ds(): boolean;
    protected get eb(): boolean;
    bj: Series;
    ml(a: Point): void;
    private i0;
    mo(): void;
    protected j1(): void;
    mn(): void;
    private c4;
    protected eo: boolean;
    b3: InteractionState;
    b5: InteractionState;
    on: ModifierKeys;
    oo: ModifierKeys;
    private pe;
    get pq(): Rect;
    set pq(a: Rect);
    ev: Date;
    es: boolean;
    protected mf(): void;
    i2(): void;
    f3: number;
    f4: number;
    private pt;
    refreshCompleted: (sender: any, e: RefreshCompletedEventArgs) => void;
    lm(): void;
    protected abstract ce(): SeriesViewerView;
    protected k5(a: SeriesViewerView): void;
    static ps: Rect;
    mu: DataTemplate;
    m3: DataTemplate;
    m0: DataTemplate;
    m1: DataTemplate;
    mv: DataTemplate;
    my: DataTemplate;
    mw: DataTemplate;
    m2: DataTemplate;
    mz: DataTemplate;
    mx: DataTemplate;
    ie: string;
    om: HorizontalAlignment;
    ol: HorizontalAlignment;
    private gk;
    get im(): string;
    set im(a: string);
    private gj;
    get h9(): string;
    set h9(a: string);
    private oq;
    get o6(): Brush;
    set o6(a: Brush);
    private op;
    get o5(): Brush;
    set o5(a: Brush);
    private fe;
    get f1(): number;
    set f1(a: number);
    private fc;
    get fz(): number;
    set fz(a: number);
    private fd;
    get f0(): number;
    set f0(a: number);
    private fb;
    get fy(): number;
    set fy(a: number);
    private fa;
    get fx(): number;
    set fx(a: number);
    private e8;
    get fv(): number;
    set fv(a: number);
    private e9;
    get fw(): number;
    set fw(a: number);
    private e7;
    get fu(): number;
    set fu(a: number);
    h2: string;
    py(): Thickness;
    pz(): Thickness;
    an(a: Axis): AxisTitlePosition;
    ao(a: Axis): AxisTitlePosition;
    abstract getFontInfo(): FontInfo;
    getFontHeight(): number;
    abstract getFontBrush(): Brush;
    abstract os(): Brush;
    gh: any;
    provideContainer(a: any): void;
    j9(a: number, b: number): void;
    notifyContainerResized(): void;
    pl(): Rect;
    jf(): void;
    o9(): Point;
    ci(): FontInfo;
    ch(): FontInfo;
    ov(): Brush;
    ow(): Brush;
    i4(a: Series): void;
    l1(a: Series): void;
    al: CanvasRenderScheduler;
    am: CanvasRenderScheduler;
    ak: CanvasRenderScheduler;
    private c1;
    get ea(): boolean;
    set ea(a: boolean);
    private cs;
    get c7(): boolean;
    set c7(a: boolean);
    private _syncSettings;
    get syncSettings(): SyncSettings;
    set syncSettings(a: SyncSettings);
    i3(a: any): void;
    l3(a: any): void;
    jy(source_: any, a: number, b: any, c: any): void;
    jt(source_: any): void;
    jw(source_: any, a: number, b: any): void;
    jx(source_: any, a: number, b: any): void;
    destroyed: boolean;
    protected gf: any;
    protected et: Dictionary$2<string, any>;
    d7: boolean;
    destroy(): void;
    protected jd(): void;
    ma(source_: any): void;
    l4(): void;
    l9(a: string, source_: any): void;
    l2(a: string, b: boolean): void;
    protected l8(a: Series, b: any): void;
    protected mi(a: any): void;
    protected mj(): void;
    private ff;
    get f2(): number;
    set f2(a: number);
    private e4;
    get fq(): number;
    set fq(a: number);
    private e6;
    get ft(): number;
    set ft(a: number);
    private e2;
    get fm(): number;
    set fm(a: number);
    private e1;
    get fl(): number;
    set fl(a: number);
    private e0;
    get fk(): number;
    set fk(a: number);
    eh(): boolean;
    private cx;
    get dn(): boolean;
    set dn(a: boolean);
    private e5;
    get fr(): number;
    set fr(a: number);
    private e3;
    get fp(): number;
    set fp(a: number);
    static b1(a: string, b: any): CoercionInfo;
    private gi;
    get hl(): string;
    set hl(a: string);
    private ex;
    get fh(): number;
    set fh(a: number);
    private ew;
    get fg(): number;
    set fg(a: number);
    private pb;
    get pg(): Rect;
    set pg(a: Rect);
    pm(): Rect;
    dj: boolean;
    private jo;
    pr(): Rect;
    protected ph(): Rect;
    gg(a: number, b: number): any;
    private ey;
    get fi(): number;
    set fi(a: number);
    private ez;
    get fj(): number;
    set fj(a: number);
    j0(): void;
    jz(): void;
    flush(): void;
    ji(a: boolean, b: boolean, c: boolean): void;
    ep(): boolean;
    private m4;
    private av;
    protected ly(a: DependencyObject, b: (arg1: boolean) => void): void;
    protected me(a: DependencyObject): void;
    jb(): void;
    dp: boolean;
    dq: boolean;
    dm: boolean;
    kj(): void;
    private cz;
    get d1(): boolean;
    i5(): void;
    d6(): boolean;
    private f8;
    gc(): number;
    cl(): FontInfo;
    ck(): FontInfo;
    mh(): void;
    protected dc: boolean;
    o4: Brush;
    o3: Brush;
    fs: number;
    dt: boolean;
    seriesDataUpdated: (sender: any, e: EventArgs) => void;
    lp(): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class SeriesViewerView extends Base implements ISchedulableRender {
    static $t: Type;
    constructor(a: SeriesViewer);
    l(): IExecutionContext;
    cl(): void;
    p: SeriesViewer;
    c1(): void;
    e(): Series;
    private ck;
    a: CanvasRenderScheduler;
    n: IOverviewPlusDetailPane;
    private dk;
    private dj;
    ej(): void;
    private cq;
    private cp;
    o: OverviewPlusDetailViewportHost;
    b8(a: number, b: number, c: RenderSurface): void;
    d2(): void;
    ca(): void;
    d4(): void;
    ch(): void;
    b9(): void;
    cb(): void;
    dv(a: Series): void;
    c9(): void;
    private eo;
    aq(a: Series): boolean;
    protected g: SeriesCollection;
    protected b: AxisCollection;
    private ai;
    get au(): boolean;
    set au(a: boolean);
    bp(a: Series): void;
    dq(a: RenderingContext): void;
    bx(): void;
    bt(): void;
    cc(): void;
    b7(): void;
    dn(): void;
    protected fd: Rectangle;
    protected fc: Path;
    d5(): void;
    ed(a: Rect): void;
    bw(): void;
    dc(): void;
    el(a: number, b: number, c: number, d: number): void;
    protected fb: Line;
    protected fa: Line;
    ea(): void;
    ci(): void;
    ee(a: number, b: number, c: number, d: number): void;
    d6(): void;
    cd(): void;
    cg(): void;
    private e3;
    private e4;
    ek(a: Rect, b: Rect): void;
    d9(): void;
    em(a: Rect): void;
    dt(a: Axis): void;
    du(a: Axis): void;
    bo(a: Axis): void;
    bl(a: Axis): void;
    private h;
    i(): SeriesViewerComponentsFromView;
    static aw(a: Series): List$1<Series>;
    dz(): void;
    j: SeriesViewerViewManager;
    protected w: RenderingContext;
    z: RenderingContext;
    y: RenderingContext;
    x: RenderingContext;
    an: boolean;
    ao: boolean;
    protected bi: any;
    cx(a: any): void;
    private al;
    protected cv(a: Point, b: boolean): void;
    protected cw(a: Point, b: boolean): void;
    protected c0(a: Point): void;
    protected cu(a: Point, b: boolean, c: boolean): void;
    dr(a: RenderingContext): void;
    protected get_ap(): boolean;
    get ap(): boolean;
    k: EventProxy;
    ec(): void;
    a9: number;
    f(a: Point, b: boolean, c: DataContext, d: boolean): {
        ret: Series;
        p2: DataContext;
    };
    bd(): number;
    bc(): number;
    a8: number;
    a7: number;
    private e6;
    private aj;
    cr(): void;
    cy(a: number, b: number): void;
    d0(): void;
    private a1;
    private az;
    private a0;
    private ay;
    private ak;
    private aa;
    private b2;
    private eh;
    v(): FontInfo;
    u(): FontInfo;
    private e2;
    private e1;
    private bf;
    private a2;
    private be;
    fh(): Thickness;
    fg(): Thickness;
    protected ds(a: Rect): void;
    cn(): void;
    private e7;
    protected dx(): void;
    isValid(): boolean;
    preRender(): void;
    protected dp(): void;
    protected ab: boolean;
    protected dy(): void;
    cz(): void;
    ct(): void;
    e8(): Rect;
    e5(): Point;
    private d3;
    eb(): void;
    dl(): void;
    protected as(a: Point): boolean;
    c5(a: Point, b: boolean, c: boolean): void;
    protected c4(a: Point): void;
    protected c3(a: Point): void;
    protected c6(a: Point): void;
    d1(): void;
    get ew(): ModifierKeys;
    en(a: Rect): void;
    co(a: boolean): void;
    bk(a: boolean): void;
    protected ei(): void;
    private af;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    undirty(a: boolean): void;
    get index(): number;
    postRender(): void;
    b6(): void;
    protected ae: boolean;
    ce(): void;
    d7(): void;
    bv(a: boolean): void;
    bm(a: any): void;
    ef(a: number): void;
    eg(a: number): void;
    bn(a: any): void;
    dw(a: any): void;
    c7(a: Brush): void;
    bu(a: Point): void;
    av: boolean;
    m(a: boolean): InteractionState;
    c2(): void;
    private eq;
    private ep;
    bb(a: TextBlock, b: FontInfo): number;
    ba(a: string, b: FontInfo): number;
    dg(): void;
    private er;
    df(): void;
    db(): void;
    c(a: Axis): AxisTitlePosition;
    d(a: Axis): AxisTitlePosition;
    dh(): void;
    di(): void;
    t(): FontInfo;
    e0(): Brush;
    q(): FontInfo;
    ex(): Brush;
    s(): FontInfo;
    r(): FontInfo;
    ez(): Brush;
    ey(): Brush;
    get a4(): number;
    get a5(): number;
    get a6(): number;
    get a3(): number;
    get et(): TextBlock;
    get es(): TextBlock;
    e9(): Rect;
    ff(): Thickness;
    fe(): Thickness;
    private ad;
    private ac;
    da(a: any, b: any): void;
    de(a: any, b: any): void;
    ev(): HorizontalAlignment;
    eu(): HorizontalAlignment;
    private ag;
    bq(): void;
    am(): boolean;
    b5(): void;
    cm(): void;
    at(a: Point): boolean;
    dm(): void;
    private ax;
    b3(a: Dictionary$2<any, ITileZoomTile>, b: List$1<ITileZoomTile>, c: number): void;
    bh(a: Rect, b: ITileZoomTile, c: number): any;
    b0(): void;
    b1(a: ITileZoomTile): void;
    cj(): void;
    ar: boolean;
    private bg;
    by(): void;
    br(): void;
    bz(a: number): void;
    bs(): void;
    private ah;
    cf(): void;
    d8(): void;
    dd(): void;
    cs(): void;
    c8(): void;
    b4(a: any): void;
    bj(a: number, b: number): any;
}
/**
 * @hidden
 */
export declare class OverviewPlusDetailViewportHost extends Base implements IProvidesViewport {
    static $t: Type;
    constructor(a: SeriesViewerView);
    a: SeriesViewerView;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    getEffectiveViewport(): Rect;
}
/**
 * @hidden
 */
export declare class SeriesViewerViewManager extends Base {
    static $t: Type;
    ae: DomRenderer;
    protected af: DomWrapper;
    protected aj: DomWrapper;
    protected ai: DomWrapper;
    protected ag: DomWrapper;
    ak: DomWrapper;
    t: RenderingContext;
    w: RenderingContext;
    v: RenderingContext;
    u: RenderingContext;
    x: RenderingContext;
    f: EventProxy;
    private j;
    constructor(a: SeriesViewerView);
    protected ah: DomWrapper;
    bi(): void;
    bf(a: any): void;
    static bx(a: DomRenderer, b: () => void): void;
    private bh;
    a9(): void;
    g(): IOverviewPlusDetailPane;
    bl(): void;
    bm(): void;
    b2(): Brush;
    private ab;
    private aa;
    private ac;
    ay(a: number, b: number, c: number): void;
    b7(): Point;
    y(): boolean;
    bb(a: boolean): void;
    a7(a: BrushCollection, b: BrushCollection, c: Brush, d: FontInfo, e: Brush): {
        p0: BrushCollection;
        p1: BrushCollection;
        p2: Brush;
        p3: FontInfo;
        p4: Brush;
    };
    e(): DefaultPaletteInfo;
    a6(a: number, b: number[], c: Brush, d: Brush, e: number, f: boolean): {
        p0: number;
        p1: number[];
        p2: Brush;
        p3: Brush;
        p4: number;
        p5: boolean;
    };
    ax(): void;
    bt(x_: number): void;
    private ad;
    bu(y_: number): void;
    at(a: any): void;
    a8(): void;
    bn(): void;
    au(a: any): void;
    bj(a: any): void;
    bc(): void;
    private l;
    p(): FontInfo;
    private b9;
    cd(): Thickness;
    private aq;
    as(): string;
    private ap;
    ar(): string;
    private b8;
    cc(): Thickness;
    private bz;
    b4(): Brush;
    private by;
    b3(): Brush;
    private k;
    o(): FontInfo;
    private a;
    c(): AxisTitlePosition;
    private b;
    d(): AxisTitlePosition;
    private n;
    r(): FontInfo;
    private b1;
    b6(): Brush;
    private m;
    q(): FontInfo;
    private b0;
    b5(): Brush;
    private ca;
    ce(): Thickness;
    private cb;
    cf(): Thickness;
    bo(): void;
    private bw;
    private bq;
    private bp;
    private br;
    private bs;
    a5(a: number, b: number): void;
    private h;
    i(): PointerTooltipStyle;
    ba(a: boolean): void;
    private z;
    an(a: Rect, b: ITileZoomTile, c: number): any;
    a2(a: ITileZoomTile): void;
    a1(): void;
    bk(a: List$1<ITileZoomTile>): void;
    private al;
    az(): void;
    av(): void;
    private am;
    a0(a: number): void;
    aw(): void;
    private s;
    bd(): void;
    bv(a: boolean): void;
    a3(): void;
    a4(): void;
    bg(): void;
    be(): void;
    ao(a: number, b: number): any;
}
/**
 * @hidden
 */
export declare class AutoRangeCalculator extends Base {
    static $t: Type;
    static a(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
}
/**
 * @hidden
 */
export interface IAxisAnnotationManager {
    owner: Axis;
    onAutoAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAutoAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAddAnnotations(a: Axis): void;
    arrangeAnnotations(a: Axis, b: AxisLabelPanelBaseView, c: List$1<FrameworkElement>, d: List$1<Rect>, e: boolean, f: number, g: number, h: number, i: number, j: number): void;
}
/**
 * @hidden
 */
export declare let IAxisAnnotationManager_$type: Type;
/**
 * @hidden
 */
export declare class AxisLabelSettings extends Base implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    private aa;
    get textStyle(): string;
    set textStyle(a: string);
    private ax;
    get textColor(): Brush;
    set textColor(a: Brush);
    get location(): AxisLabelsLocation;
    set location(a: AxisLabelsLocation);
    private b;
    get visibility(): Visibility;
    set visibility(a: Visibility);
    private a2;
    get showFirstLabel(): boolean;
    set showFirstLabel(a: boolean);
    private h;
    c: AxisLabelsLocation;
    a: Axis;
    registerAxis(a: Axis): void;
    unregisterAxis(a: Axis): void;
    get angle(): number;
    set angle(a: number);
    private m;
    get extent(): number;
    set extent(a: number);
    private o;
    set margin(a: number);
    get leftMargin(): number;
    set leftMargin(a: number);
    private p;
    get rightMargin(): number;
    set rightMargin(a: number);
    private q;
    get topMargin(): number;
    set topMargin(a: number);
    private r;
    get bottomMargin(): number;
    set bottomMargin(a: number);
    private n;
    private au;
    get horizontalAlignment(): HorizontalAlignment;
    set horizontalAlignment(a: HorizontalAlignment);
    private az;
    get verticalAlignment(): VerticalAlignment;
    set verticalAlignment(a: VerticalAlignment);
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    ar(a: string, b: any, c: any): void;
    protected aq(a: any, b: string, c: any, d: any): void;
    j(): boolean;
    k(): boolean;
    static readonly extentPropertyDefault: number;
    get i(): boolean;
    private f;
    g(a: DomRenderer): FontInfo;
}
/**
 * @hidden
 */
export declare class TitleSettings extends AxisLabelSettings {
    static $t: Type;
    constructor();
    private a4;
    get position(): AxisTitlePosition;
    set position(a: AxisTitlePosition);
    protected aq(a: any, b: string, c: any, d: any): void;
}
/**
 * @hidden
 */
export declare abstract class Axis extends Control implements INotifyPropertyChanged {
    static $t: Type;
    a3(): AxisView;
    a4: AxisView;
    ha(a: AxisView): void;
    gx(): void;
    private bs;
    get bt(): SRProvider;
    private a8;
    get a9(): IAxisVisualDataManager;
    d7(): number;
    fl(): any;
    fk(): any;
    protected get_b6(): boolean;
    get b6(): boolean;
    protected get_ce(): boolean;
    get ce(): boolean;
    protected get_b4(): boolean;
    get b4(): boolean;
    protected get_cg(): boolean;
    get cg(): boolean;
    protected get_cj(): boolean;
    get cj(): boolean;
    protected get_ch(): boolean;
    get ch(): boolean;
    protected get_b9(): boolean;
    get b9(): boolean;
    protected get_cf(): boolean;
    get cf(): boolean;
    protected get_b7(): boolean;
    get b7(): boolean;
    protected get_b8(): boolean;
    get b8(): boolean;
    aj(): Axis;
    constructor();
    private a6;
    get a7(): IAxisAnnotationManager;
    get b5(): boolean;
    private gv;
    private gw;
    private gt;
    private gu;
    provideRenderer(a: DomRenderer): void;
    at: (item: any) => string;
    g7(a: Rect, b: Rect): void;
    abstract au(): AxisLabelPanelBase;
    ac(): void;
    h5: Canvas;
    get bn(): IFastItemsSourceProvider;
    set bn(a: IFastItemsSourceProvider);
    private bm;
    get bh(): SeriesViewer;
    set bh(a: SeriesViewer);
    private bg;
    get bf(): XamDataChart;
    set bf(a: XamDataChart);
    readonly br: (sender: any, e: RectChangedEventArgs) => void;
    private bw;
    get cz(): boolean;
    set cz(a: boolean);
    private dd;
    get ep(): number;
    set ep(a: number);
    private c8;
    get dp(): number;
    set dp(a: number);
    private dj;
    get ev(): number;
    set ev(a: number);
    private dg;
    get es(): number;
    set es(a: number);
    private ar;
    get as(): AxisExtentType;
    set as(a: AxisExtentType);
    private dc;
    get eo(): number;
    set eo(a: number);
    dn: number;
    private di;
    get eu(): number;
    set eu(a: number);
    private df;
    get er(): number;
    set er(a: number);
    private bj;
    private bi;
    get bl(): FontInfo;
    set bl(a: FontInfo);
    private fm;
    get gg(): string;
    set gg(a: string);
    private de;
    get eq(): number;
    set eq(a: number);
    dq: number;
    private dk;
    get ew(): number;
    set ew(a: number);
    private dh;
    get et(): number;
    set et(a: number);
    private e7;
    get fc(): number;
    set fc(a: number);
    private e6;
    get fb(): number;
    set fb(a: number);
    private e5;
    get fa(): number;
    set fa(a: number);
    e8: number;
    private jy;
    get j1(): VerticalAlignment;
    set j1(a: VerticalAlignment);
    private dm;
    get ey(): number;
    set ey(a: number);
    private dl;
    get ex(): number;
    set ex(a: number);
    hw(): void;
    private hn;
    private ho;
    h6: TextBlock;
    gp: string;
    je: Brush;
    ja: Brush;
    ez: number;
    ji: DoubleCollection;
    jd: Brush;
    jb: Brush;
    i8: Brush;
    ef: number;
    jg: DoubleCollection;
    jc: Brush;
    i9: Brush;
    ei: number;
    jh: DoubleCollection;
    jf: Brush;
    e1: number;
    jj: DoubleCollection;
    e0: number;
    dr: number;
    private hz;
    ca: boolean;
    cc: boolean;
    cd: boolean;
    co: boolean;
    cp: boolean;
    cq: boolean;
    cr: boolean;
    get cy(): boolean;
    set cy(a: boolean);
    static readonly i5: DependencyProperty;
    e9: number;
    by: boolean;
    ay: AxisLabelSettings;
    dw(): number;
    i6(): HorizontalAlignment;
    jz(): VerticalAlignment;
    i7(): HorizontalAlignment;
    j0(): VerticalAlignment;
    dy(): number;
    d0(): number;
    dz(): number;
    dx(): number;
    d3(): number;
    d5(): number;
    d4(): number;
    d2(): number;
    az(): AxisLabelsLocation;
    a0(): AxisLabelsLocation;
    ai: Axis;
    fe: any;
    rangeChanged: (sender: any, e: AxisRangeChangedEventArgs) => void;
    protected hl(a: AxisRangeChangedEventArgs): void;
    be: TitleSettings;
    d1(): number;
    dv(): number;
    get am(): AxisAnnotationCollection;
    private ak;
    get an(): AxisAnnotationCollection;
    private al;
    private jl;
    get js(): Rect;
    set js(a: Rect);
    jr: Rect;
    h0(): void;
    c1(a: Rect, b: Rect, c: AxisView): boolean;
    ci(): boolean;
    c5: List$1<any>;
    c6: List$1<LabelPosition>;
    av: AxisLabelPanelBase;
    protected h3(a: Rect, b: Rect): void;
    private bv;
    get ck(): boolean;
    set ck(a: boolean);
    protected jp(): Rect;
    protected h4(a: Rect, b: Rect): void;
    hm(): void;
    a5: ContentInfo;
    e4: DomRenderer;
    ah: BindingFormatter;
    protected he(a: any, b: string, c: any, d: any): void;
    hc(): void;
    hd(): void;
    private _coercionMethods;
    get coercionMethods(): any;
    set coercionMethods(a: any);
    private bu;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    get expectFunctions(): boolean;
    set expectFunctions(a: boolean);
    cs: boolean;
    private ht;
    c0: boolean;
    protected g9(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected g8(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    protected h2(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected h1(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    private cb;
    protected hv(a: number, b: number, c: Rect, d: Rect, e: Rect, f: number, g: number): {
        p0: number;
        p1: number;
    };
    ds(a: number, b: number, c: number, d: PathRenderingInfo): number;
    g0(a: GeometryCollection): void;
    protected gz(): void;
    hp(): void;
    hq(a: boolean): void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    bb: LabelFontHeuristics;
    static eh: number;
    em(): number;
    ek(): number;
    ct(a: number, b: Rect, c: Rect, d: Rect): boolean;
    protected d6(a: number, b: Rect, c: Rect, d: Rect): number;
    el(): number;
    protected get cu(): boolean;
    cl: boolean;
    g2(a: boolean): void;
    private da;
    private bz;
    hs(): void;
    protected b2(): boolean;
    dt(a: number, b: ScalerParams): number;
    protected hu(): void;
    private db;
    ba(): LabelFontHeuristics;
    bk(): FontInfo;
    private g3;
    cm: boolean;
    cv(): boolean;
    cw(a: boolean): boolean;
    cx(): boolean;
    protected hr(a: boolean): void;
    hy(): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected hk(a: string, b: any, c: any): void;
    c7: List$1<Series>;
    cn(a: Series): boolean;
    bx(a: Series): boolean;
    fj: any;
    fz: string;
    ag: any[];
    fg(a: any, b: string): any;
    private c3;
    protected gb(a: string): string;
    private c2;
    protected fh(a: any, b: string, c: string): any;
    fi(a: any): any;
    fw(a: number): string;
    ej(): number;
    d8(a: number, b: ScalerParams): number;
    d9(a: number, b: ScalerParams, c: CategoryMode): number;
    jo(a: Rect): Rect;
    jn(): Rect;
    jm(): Rect;
    protected jq(a: Rect, b: Rect): Rect;
    ea(a: number, b: Rect, c: Rect): number;
    g5(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    g4(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    eb(a: number, b: ScalerParams): number;
    ec(a: number, b: ScalerParams, c: CategoryMode): number;
    ed(a: number, b: Rect, c: Rect): number;
    g6(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    en(a: number): number;
    abstract get a1(): AxisOrientation;
    jx: Size;
    hb(a: Size): void;
    hx(): void;
    ao: AxisComponentsForView;
    ap(): AxisComponentsForView;
    du: number;
    private c9;
    get eg(): number;
    set eg(a: number);
    b3(): boolean;
    ee(): number;
    protected gy(): void;
    g1(a: AxisRangeChangedEventArgs): void;
    bq: Pool$1<TextBlock>;
    bp: Pool$1<TextBlock>;
    bo: Pool$1<Rectangle>;
    get jt(): Path;
    get ju(): Path;
    get jw(): Path;
    get jv(): Path;
    bd(): SyncSettings;
    aq(): AxisComponentsFromView;
    private aw;
    get ax(): AxisLabelSettings;
    hf(a: RenderingContext, b: RenderingContext): void;
    b1(): boolean;
    ff(): any;
    private _c4;
    c4(): IEnumerable$1<Series>;
    hg(a: string): void;
    hj(a: any): void;
    hi(a: any): void;
    e3: CultureInfo;
    jk(a: number, b: Rect, c: Rect, d?: any, e?: any): Geometry;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisCollection extends ObservableCollection$1<Axis> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class AxisLabelManager extends Base {
    static $t: Type;
    e: List$1<any>;
    f: List$1<LabelPosition>;
    b: AxisLabelPanelBase;
    a: Axis;
    c: (arg1: number) => void;
    constructor();
    n(a: Rect, b: Rect): void;
    i(a: any, b: LabelPosition): void;
    t(): void;
    static j(a: FrameworkElement, b: AxisLabelSettings): void;
    private static k;
    private static l;
    static m(a: FrameworkElement, b: TitleSettings): void;
    h(a: FrameworkElement): void;
    r(a: number): void;
    o(a: number): void;
    u(a: number): FrameworkElement;
    s(a: number): void;
    get d(): boolean;
    q(): void;
    p(): void;
    g(): void;
}
/**
 * @hidden
 */
export declare abstract class AxisLabelPanelBase extends Panel {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    cc(a: AxisLabelPanelBaseView): void;
    ae: AxisLabelPanelBaseView;
    cr: Rect;
    b3(): void;
    cj(): void;
    ci(): void;
    constructor();
    br: number;
    ac: Axis;
    private aj;
    get av(): boolean;
    set av(a: boolean);
    private az;
    get a5(): List$1<any>;
    set a5(a: List$1<any>);
    a6: List$1<LabelPosition>;
    cw: Rect;
    private cq;
    get cx(): Rect;
    set cx(a: Rect);
    private cp;
    get cu(): Rect;
    set cu(a: Rect);
    cv: Rect;
    private a8;
    get bc(): number;
    set bc(a: number);
    bs: () => boolean;
    a7: List$1<FrameworkElement>;
    a4: List$1<Rect>;
    af: AxisLabelSettings;
    an: boolean;
    ar: boolean;
    as: boolean;
    at: boolean;
    bu: any;
    ak: boolean;
    protected am(a: List$1<Rect>, b: List$1<boolean>): boolean;
    protected bt(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    a1(): List$1<Rect>;
    b1(): void;
    bx(a: Size): void;
    bh(): number;
    bl(): number;
    aq(a: number, b: Rect): boolean;
    bg(a: any): number;
    bq(a: any): number;
    bi(a: any): number;
    bf(a: any): number;
    ao(): boolean;
    protected cn(a: Rect, b: Rect): void;
    protected b8(a: Rect, b: Rect): void;
    a3(): List$1<Rect>;
    a2(a: List$1<Rect>): List$1<Rect>;
    protected cs(a: number, b: Rect, c: Thickness): Rect;
    protected ap(a: List$1<Rect>, b: List$1<number>, c: Thickness): boolean;
    protected a0(a: List$1<Rect>): List$1<number>;
    bk(a: number, b: Size): number;
    bj(a: number, b: Size): number;
    bo(): number;
    bm(): number;
    bn(): number;
    bp(): number;
    cy(a: Size): Size;
    protected get al(): boolean;
    ct(): Rect;
    protected b0(a: Size): void;
    protected bz(a: Size): void;
    protected b4(): void;
    protected ay(): IEnumerable$1<number>;
    get ag(): AxisLabelsLocation;
    cm(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    b7(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    cg(a: FrameworkElement, b: number): void;
    ch(a: FrameworkElement): void;
    b6(a: FrameworkElement, b: number): void;
    c0(a: Size): Size;
    static readonly co: DependencyProperty;
    get bd(): number;
    set bd(a: number);
    a9: number;
    ai(a: TitleSettings): AxisTitlePosition;
    ah(): AxisLabelsLocation;
    au(a: AxisLabelsLocation): boolean;
    private _aw;
    aw(): IEnumerable$1<any>;
    bw(a: number, b: TextBlock, c: number, d: number, e: number): string;
    b2(a: any): void;
    cb(a: FrameworkElement): void;
    private _ax;
    ax(): IEnumerable$1<any>;
    protected ba: number;
    protected bb: number;
    b5(): void;
    cl(): void;
    b9(): void;
    be(a: Rect): number;
    cz: Size;
    cd(): void;
    ck(): void;
    ca(): void;
    ce(a: RenderingContext): void;
    by(): void;
    cf(): void;
}
/**
 * @hidden
 */
export declare abstract class CategoryAxisBase extends Axis implements ICategoryScaler {
    static $t: Type;
    a3(): AxisView;
    protected get_b8(): boolean;
    ha(a: AxisView): void;
    j2: CategoryAxisBaseView;
    protected d6(a: number, b: Rect, c: Rect, d: Rect): number;
    constructor();
    c1(a: Rect, b: Rect, c: AxisView): boolean;
    la(): void;
    k9(): void;
    kd: List$1<number>;
    protected get_b6(): boolean;
    ll(a: Point, b: boolean, c: number): Rect;
    lm(a: Point, b: boolean, c: number, d: boolean): Rect;
    j6: IFastItemsSource;
    private j5;
    get itemsSource(): IEnumerable;
    set itemsSource(a: IEnumerable);
    static readonly li: DependencyProperty;
    private ko;
    kq: number;
    get kr(): number;
    set kr(a: number);
    get categoryMode(): CategoryMode;
    set categoryMode(a: CategoryMode);
    private j3;
    kf: number;
    km: number;
    ka: boolean;
    get ks(): number;
    set ks(a: number);
    private kp;
    eb(a: number, b: ScalerParams): number;
    getUnscaledValue3(a: number, b: Rect, c: Rect, d: CategoryMode): number;
    getCategorySize(a: Rect, b: Rect, c: Rect): number;
    ki(a: Rect, b: Rect, c: Rect): number;
    getGroupCenter(a: number, b: Rect, c: Rect, d: Rect): number;
    kn(a: number): number;
    private _kc;
    private kc;
    private j8;
    j9(a: SeriesViewer): boolean;
    private _kb;
    private kb;
    private j7;
    le(a: boolean): void;
    protected he(a: any, b: string, c: any, d: any): void;
    protected k2(): void;
    k4(a: any, b: FastItemsSourceEventArgs): void;
    protected lb(a: FastItemsSourceEventArgs): void;
    private lf;
    cn(a: Series): boolean;
    bx(a: Series): boolean;
    private lc;
    k1(): void;
    ld(): void;
    k3(a: NotifyCollectionChangedEventArgs): void;
    k8(a: number, b: any, c: any): void;
    k5(): void;
    k6(a: number, b: any): void;
    k7(a: number, b: any): void;
    kj(a: Rect, b: Rect, c: Rect, d: number): number;
    kk(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    getSeriesOffset(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    get isVertical(): boolean;
    j$c(a: number, b: ScalerParams): number;
    j$b(a: number, b: ScalerParams): number;
    j$d(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    j$e(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    j$f(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    get j$a(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class HorizontalAxisLabelPanelBase extends AxisLabelPanelBase {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    cc(a: AxisLabelPanelBaseView): void;
    c1: HorizontalAxisLabelPanelBaseView;
    dd: number;
    da: number;
    dc: number;
    db: number;
    b1(): void;
    c3(): boolean;
    c4(): boolean;
    ao(): boolean;
    a1(): List$1<Rect>;
    df(a: List$1<Rect>, b: List$1<boolean>, c: number): void;
    private de;
    private dg;
    protected dh(a: List$1<Rect>, b: List$1<boolean>): void;
    protected di(): void;
    cg(a: FrameworkElement, b: number): void;
    protected c5(): boolean;
    protected c2(): boolean;
    protected bt(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    ct(): Rect;
    c9(): number;
    c6(): number;
    c8(): number;
    c7(): number;
    protected b4(): void;
    a2(a: List$1<Rect>): List$1<Rect>;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanel extends HorizontalAxisLabelPanelBase {
    static $t: Type;
    ah(): AxisLabelsLocation;
    au(a: AxisLabelsLocation): boolean;
}
/**
 * @hidden
 */
export declare abstract class NumericAxisBase extends Axis {
    static $t: Type;
    a3(): AxisView;
    ha(a: AxisView): void;
    dt(a: number, b: ScalerParams): number;
    j3: NumericAxisBaseView;
    protected get_ce(): boolean;
    constructor();
    k3: number;
    get kv(): number;
    set kv(a: number);
    private kp;
    k1: number;
    fl(): any;
    get ky(): number;
    set ky(a: number);
    private ks;
    k2: number;
    get ku(): number;
    set ku(a: number);
    private ko;
    fk(): any;
    k0: number;
    private kr;
    get kx(): number;
    set kx(a: number);
    kz: number;
    private kn;
    get kt(): number;
    set kt(a: number);
    ej(): number;
    k4: number;
    private kq;
    get kw(): number;
    set kw(a: number);
    k5: number;
    kk: boolean;
    private ke;
    get kg(): boolean;
    set kg(a: boolean);
    get kl(): boolean;
    k7: number;
    k8: number;
    j6: NumericAxisRenderer;
    protected km: boolean;
    protected hr(a: boolean): void;
    hj(a: any): void;
    hi(a: any): void;
    protected he(a: any, b: string, c: any, d: any): void;
    protected ls(): void;
    j2(): AxisRange;
    lq(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
    cx(): boolean;
    lt(a: AxisRangeChangedEventArgs): void;
    cn(a: Series): boolean;
    bx(a: Series): boolean;
    j5(a: AxisLabelManager): NumericAxisRenderer;
    j4(): NumericAxisRenderer;
    j8(): NumericAxisRenderingParameters;
    lr(): void;
    j9(): NumericScaler;
    j7(a: Rect, b: Rect, c: Rect, d: Rect): NumericAxisRenderingParameters;
    k6(a: number): number;
    kh(): boolean;
    get kj(): boolean;
    get ki(): boolean;
    private lu;
    static readonly l2: DependencyProperty;
    get kc(): TickmarkValues;
    set kc(a: TickmarkValues);
    private ka;
    get kb(): TickmarkValues;
    set kb(a: TickmarkValues);
    private kd;
    get kf(): boolean;
    set kf(a: boolean);
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class NumericScaler extends DependencyObject {
    static $t: Type;
    static readonly ac: Rect;
    abstract t(a: NumericAxisBase, b: number, c: number, d: number, e: number): {
        p3: number;
        p4: number;
    };
    l: number;
    k: number;
    protected o: number;
    protected n: number;
    y(a: number): void;
    x(a: number): void;
    protected w(a: string, b: any, c: any): void;
    private z;
    protected m: number;
    abstract q(a: number, b: ScalerParams): number;
    abstract p(a: number, b: ScalerParams): number;
    j(a: IList$1<number>, b: number, c: number, d: ScalerParams): IList$1<number>;
    v(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    u(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisRendererBase extends Base {
    static $t: Type;
    constructor(a: AxisLabelManager);
    u: () => void;
    o: (viewportRect: Rect, windowRect: Rect) => boolean;
    v: () => void;
    m: (p: AxisRenderingParametersBase, value: number) => number;
    l: (p: AxisRenderingParametersBase, geometry: GeometryCollection, startValue: number, endValue: number) => void;
    k: (p: AxisRenderingParametersBase, geometry: GeometryCollection, value: number) => void;
    q: (p: AxisRenderingParametersBase, value: number) => boolean;
    n: (p: AxisRenderingParametersBase, value: number) => boolean;
    j: (p: AxisRenderingParametersBase) => void;
    e: (p: AxisRenderingParametersBase) => void;
    p: (p: AxisRenderingParametersBase, position: number, isLastLabel: boolean) => boolean;
    h: (p: AxisRenderingParametersBase, value: number) => LabelPosition;
    t: (p: AxisRenderingParametersBase, value: number) => number;
    b: AxisLabelManager;
    g: (item: any) => any;
    d: (viewportRect: Rect, windowRect: Rect, effectiveViewportRect: Rect, contentViewport: Rect) => AxisRenderingParametersBase;
    r: (p: AxisRenderingParametersBase, value: number, absoluteIndex: number, interval: number) => number;
    a: (p: AxisRenderingParametersBase, value: number, absolueIndex: number, interval: number) => number;
    f: (index: number, window: Rect, viewport: Rect, effectiveViewport: Rect) => number;
    i: (index: number) => number;
    c(a: boolean, b: Rect, c: Rect, d: Rect, e: Rect): AxisRenderingParametersBase;
    private aa;
    private ab;
    protected x(a: Rect, b: Rect): void;
    private z;
    private s;
    private y;
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
}
/**
 * @hidden
 */
export declare class NumericAxisRenderer extends AxisRendererBase {
    static $t: Type;
    constructor(a: AxisLabelManager);
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
    private ac;
    private ad;
    private ae;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanel extends AxisLabelPanelBase {
    static $t: Type;
    ad(): AxisLabelPanelBaseView;
    cc(a: AxisLabelPanelBaseView): void;
    c1: VerticalAxisLabelPanelView;
    da: number;
    c7: number;
    c9: number;
    c8: number;
    b1(): void;
    bl(): number;
    c3(): number;
    c5(): number;
    c6(): number;
    c4(): number;
    a1(): List$1<Rect>;
    private db;
    private dc;
    cg(a: FrameworkElement, b: number): void;
    protected c2(): boolean;
    ct(): Rect;
    ai(a: TitleSettings): AxisTitlePosition;
    ah(): AxisLabelsLocation;
    au(a: AxisLabelsLocation): boolean;
    protected b4(): void;
}
/**
 * @hidden
 */
export interface IHasCategoryAxis {
    readonly categoryAxis: CategoryAxisBase;
    getOffsetValue(): number;
    getCategoryWidth(): number;
}
/**
 * @hidden
 */
export declare let IHasCategoryAxis_$type: Type;
/**
 * @hidden
 */
export interface IHasCategoryModePreference extends IHasCategoryAxis {
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
}
/**
 * @hidden
 */
export declare let IHasCategoryModePreference_$type: Type;
/**
 * @hidden
 */
export interface IHighlightingManager {
    startHighlight(a: HighlightingInfo): void;
    endHighlight(a: HighlightingInfo): void;
    clear(): void;
    getHighlightingInfo(a: Series, b: IFastItemsSource, c: number, d: number, e: boolean): HighlightingInfo;
    tick(a: number): boolean;
    inProgress: boolean;
    maxHighlightingProgress: number;
    totalHighlightingProgress: number;
    sumHighlightingProgress: number;
    maxMarkerHighlightingProgress: number;
    sumMarkerHighlightingProgress: number;
    readonly dirtySeries: List$1<Series>;
    readonly allDirty: boolean;
    isCrossSeriesHighlight(a: Series): boolean;
    executionContext: IExecutionContext;
    ensureAnimator: () => void;
    highlightingBehavior: SeriesHighlightingBehavior;
}
/**
 * @hidden
 */
export declare let IHighlightingManager_$type: Type;
/**
 * @hidden
 */
export declare class HighlightingInfo extends Base {
    static $t: Type;
    constructor();
    i: number;
    h: number;
    g: number;
    a: HighlightingState;
    f: number;
    e: boolean;
    d: boolean;
    c: boolean;
    b: Series;
}
/**
 * @hidden
 */
export interface ISeriesInteractionManager {
    a$j(a: Series, b: Point, c: number, d: Axis, e: ScalerParams, f: number, g: number, h: (arg1: Point) => number): number;
    a$m(a: Series, b: IList$1<number>, c: Point, d: Axis, e: ScalerParams, f: number, g: (arg1: Point) => number, h: boolean, i: boolean): number;
    a$l(a: Series, b: number, c: IList$1<number>, d: number, e: number, f: number, g: number, h: number, i: boolean): number;
    a$o(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$d(a: Series, b: Point, c: boolean): boolean;
    a$a(a: Series, b: CategoryAxisBase, c: List$1<number[]>, d: number, e: number, f: Point, g: boolean): number[][];
    a$e(a: Series, b: Point, c: boolean, d: PathGeometry): boolean;
    a$f(a: Series, b: Point, c: PathGeometry): boolean;
    a$n(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$k(a: Series, b: Point, c: Axis): number;
    a$g(a: Series, b: Point, c: boolean): boolean;
    a$al(a: Series, b: Point, c: boolean, d: boolean, e: number, f: Axis, g: Axis, h: (arg1: Point, arg2: boolean, arg3: boolean) => number, i: (arg1: Point, arg2: boolean) => number, j: (arg1: Point, arg2: boolean) => number): Point;
    a$v(a: Series, b: any, c: Point, d: boolean, e: boolean, f: boolean, g: boolean, h: boolean, i: boolean): void;
    a$s(): void;
    a$ak(a: Series, b: HighlightingInfo, c: Brush): Brush;
    a$i(a: Series, b: HighlightingInfo, c: number, d: number, e: number, f: number, g: boolean): number;
    a$y(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$ai(a: Series, b: Point): void;
    a$ab(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$z(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$w(a: Series, b: Point, c: any, d: any): void;
    a$aa(a: Series, b: Point, c: any, d: any): void;
    a$x(a: Series, b: Point, c: any, d: any): void;
    a$ac(a: Series, b: Point, c: any, d: any): void;
    a$ad(a: Series, b: Point, c: any, d: any): void;
    a$q(a: Series): string;
    a$r(a: Series): string;
    readonly a$b: boolean;
    readonly a$p: any;
    a$aj(a: Series, b: any): void;
    a$ah(a: Series, b: Point, c: (arg1: any) => void): void;
    a$u(a: Series): void;
    a$ag(a: Series): void;
    readonly a$c: boolean;
    readonly a$h: Dictionary$2<string, SeriesView>;
    a$t(a: Series, b: Rect, c: Rect, d: string, e: number): void;
    a$ae(a: Series, b: SeriesViewer): void;
    a$af(a: Series, b: string, c: SeriesViewer): void;
}
/**
 * @hidden
 */
export declare let ISeriesInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesViewerInteractionManager {
    f$a(a: SeriesViewer): ChartHitTestMode;
    f$ae(a: SeriesViewer): void;
    f$p(a: SeriesViewer, b: Point): void;
    f$ac(a: SeriesViewer, b: Point): void;
    f$q(a: SeriesViewer, b: Point, c: boolean): void;
    f$o(a: SeriesViewer, b: Point): void;
    f$aj(a: SeriesViewer): void;
    f$ab(a: SeriesViewer, b: Point): void;
    f$ak(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$aa(a: SeriesViewer, b: number): void;
    f$ag(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$x(a: SeriesViewer, b: Point): void;
    f$z(a: SeriesViewer, b: number): void;
    f$r(a: SeriesViewer, b: Point): void;
    f$af(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$m(a: SeriesViewer, b: Point, c: boolean): void;
    f$ai(a: SeriesViewer): void;
    f$ah(a: SeriesViewer): void;
    f$an(a: SeriesViewer): void;
    f$j(a: SeriesViewer): void;
    f$g(a: SeriesViewer): void;
    f$l(a: SeriesViewer, b: Point, c: boolean): void;
    f$k(a: SeriesViewer, b: Point, c: boolean, d: boolean): void;
    f$al(a: SeriesViewer): void;
    f$ad(a: SeriesViewer): void;
    f$d(a: SeriesViewer, b: Key): boolean;
    f$e(a: SeriesViewer, b: Point, c: number): boolean;
    f$n(a: SeriesViewer, b: Point): void;
    f$i(a: SeriesViewer): void;
    f$h(a: SeriesViewer): void;
    readonly f$b: IHighlightingManager;
    f$am(a: SeriesViewer, b: Point): void;
    f$c(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: DataContext, g: boolean): {
        ret: Series;
        p5: DataContext;
    };
    f$f(a: SeriesViewer, b: Point): boolean;
    f$v(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: boolean): void;
    f$u(a: SeriesViewer, b: Point): void;
    f$t(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$w(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$s(a: SeriesViewer, b: Point, c: boolean): void;
    f$y(a: SeriesViewer, b: boolean): void;
}
/**
 * @hidden
 */
export declare let ISeriesViewerInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface IDataChartVisualDataManager {
    exportVisualData(a: XamDataChart): any;
}
/**
 * @hidden
 */
export declare let IDataChartVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface IAxisVisualDataManager {
    exportVisualData(a: Axis): any;
}
/**
 * @hidden
 */
export declare let IAxisVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesVisualDataManager {
    exportVisualData(a: Series, b: Rect): any;
    exportMarkerVisualData(a: MarkerSeries, b: any): void;
    getMarkerVisualData(a: Series, b: Marker, c: DataTemplate): any;
    copyVisualData(a: any, b: any): void;
    exportTrendlineData(a: Series, b: any, c: Polyline): void;
    exportStackedVisualData(a: Series, b: Rect): any;
    createFragmentVisualData(a: Series, b: Rect, c: string, d: string): any;
    addSubSeriesVisualData(a: any, b: any): void;
    exportRectangleData(a: any, b: Rectangle, c: string, d: string[]): void;
    exportMarkerVisualDataFromMarker(a: Series, b: any, c: ContentControl): void;
    exportPathData(a: any, b: Path, c: string, d: string[]): void;
    exportPolylineData(a: any, b: Polyline, c: string, d: string[]): void;
    exportPolygonData(a: any, b: Polygon, c: string, d: string[]): void;
    exportSeriesPixelsData(a: any, b: number[], c: number, d: number): void;
    addPointerTooltipData(a: any, b: any, c: number, d: number, e: List$1<string>): void;
    exportPointerTooltipData(a: Polygon, b: Polyline, c: Rectangle, d: Rect): any;
    exportCalloutData(a: number, b: number, c: number, d: number, e: any, f: Rectangle, g: TextBlock, h: FontInfo, i: Line, j: string, k: string[]): void;
}
/**
 * @hidden
 */
export declare let ISeriesVisualDataManager_$type: Type;
/**
 * @hidden
 */
export declare class XamDataChart extends SeriesViewer {
    static $t: Type;
    static rc: number;
    static rb: number;
    private _xsr;
    private get XSRP();
    private p7;
    get p8(): IDataChartVisualDataManager;
    static staticInit(): void;
    static rl(a: Series): number;
    constructor();
    protected lh(a: any, b: string, c: any, d: any): void;
    protected j5(): void;
    si(): void;
    private se;
    private s4;
    private s5;
    qk: boolean;
    fn(): number;
    fo(): number;
    protected mf(): void;
    rj: number;
    rk: number;
    private qv;
    get q7(): number;
    set q7(a: number);
    private qw;
    get q8(): number;
    set q8(a: number);
    d4(): boolean;
    d5(): boolean;
    qh: boolean;
    qp: boolean;
    qi: boolean;
    ql: boolean;
    p6: GridMode;
    qe: boolean;
    qo: boolean;
    ra: number;
    q9: number;
    qn: boolean;
    qj: boolean;
    qm: boolean;
    private qx;
    private qy;
    private rd;
    private re;
    sh(): void;
    sg(a: AxisLabelPanelBase, b: Rect, c: Rect, d: Rect): void;
    s3: Brush;
    s1: Brush;
    s2: Brush;
    get axes(): AxisCollection;
    private p2;
    private sb;
    private sc;
    axisRangeChanged: (sender: any, e: ChartAxisRangeChangedEventArgs) => void;
    private sd;
    private static sf;
    mp(a: SyncLink, b: SyncLink): void;
    private qa;
    getFontInfo(): FontInfo;
    sj(): void;
    getFontBrush(): Brush;
    protected jd(): void;
    os(): Brush;
    eh(): boolean;
    protected mj(): void;
    di(): boolean;
    private qg;
    protected ce(): SeriesViewerView;
    protected k5(a: SeriesViewerView): void;
    p9: XamDataChartView;
    lx(): void;
    private qd;
    static ro: string;
    private qs;
    get q4(): number;
    set q4(a: number);
    static rq: string;
    private qu;
    get q6(): number;
    set q6(a: number);
    static rp: string;
    private qt;
    get q5(): number;
    set q5(a: number);
    static rn: string;
    private qr;
    get q3(): number;
    set q3(a: number);
    p4: ComputedPlotAreaMarginMode;
    private q0;
    get rg(): number;
    set rg(a: number);
    private q2;
    get ri(): number;
    set ri(a: number);
    private q1;
    get rh(): number;
    set rh(a: number);
    private qz;
    get rf(): number;
    set rf(a: number);
    protected pi(a: Rect): Rect;
    po(): Rect;
    rm(): any;
    r0(): string;
    le(): void;
    lz(): void;
    qq(a: Axis): List$1<Axis>;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class LabelPanelArranger extends Base {
    static $t: Type;
    static e(a: List$1<AxisLabelPanelBase>, b: Rect): Rect;
    private static a;
    static b(a: AxisLabelPanelBase): AxisLabelsLocation;
    private static c;
    static d(a: List$1<AxisLabelPanelBase>, b: LabelPanelsArrangeState, c: Rect, d: (arg1: AxisLabelPanelBase, arg2: Rect) => void): void;
}
/**
 * @hidden
 */
export declare class ChartContentManager extends DependencyObject {
    static $t: Type;
    private l;
    private r;
    private t;
    private get u();
    private set u(value);
    constructor(a: SeriesViewer);
    k(a: ChartContentType, b: DependencyObject, c: (arg1: boolean) => void): ContentInfo;
    ad(a: ChartContentType, b: DependencyObject): void;
    private m;
    private v;
    aa(a: DomRenderer): void;
    z(): void;
    ac(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: boolean): void;
    private q;
    private j;
    y(): void;
    private w;
    private _s;
    private s;
    x(a: Size): void;
    o: boolean;
    n: boolean;
    p: boolean;
    ae(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: Rect): void;
    ab(a: Axis, b: ContentInfo): void;
}
/**
 * @hidden
 */
export declare class ContentInfo extends Base {
    static $t: Type;
    h: DependencyObject;
    a: (arg1: boolean) => void;
    b: boolean;
    c: boolean;
    i: Rect;
    get d(): boolean;
    g(): void;
    f(): void;
    e: boolean;
}
/**
 * @hidden
 */
export declare abstract class Series extends Control implements INotifyPropertyChanged, IProvidesViewport, ILegendSeries, ILegendSeriesInternal, ILegendOwner, ILegendTemplateProvider {
    static $t: Type;
    bx: SeriesView;
    private static gx;
    hc: number;
    o6: Rect;
    private gv;
    get gw(): DomRenderer;
    set gw(a: DomRenderer);
    provideRenderer(a: DomRenderer): void;
    jb(): string;
    constructor();
    mh(a: MarkerOutlineMode): void;
    mg(a: MarkerFillMode): void;
    mi(a: number): void;
    private static readonly n9;
    protected j9(a: any, b: PropertyChangedEventArgs): void;
    private cj;
    get ck(): SRProvider;
    private a5;
    get a6(): ISeriesVisualDataManager;
    protected get e6(): Dictionary$2<string, SeriesView>;
    private a3;
    get a4(): ISeriesInteractionManager;
    get dt(): boolean;
    cb: DoubleAnimator;
    lh(a: SeriesView): void;
    lf(): void;
    lg(): void;
    bv(): SeriesView;
    protected bu(): SeriesView;
    mr: Canvas;
    e0(): boolean;
    hk(a: any, b: string): any;
    onLegendItemOver(a: any): void;
    onLegendItemPointerUp(a: any): void;
    onLegendItemPointerDown(a: any): void;
    onLegendItemEnter(a: any): void;
    onLegendItemLeave(a: any): void;
    private e5;
    protected ja(a: string): string;
    private e4;
    protected hl(a: any, b: string, c: string): any;
    fw(a: Point): number;
    g2(a: Point): number;
    protected get_d3(): boolean;
    get d3(): boolean;
    ar(): CategoryAxisBase;
    g0(a: Point): number;
    pg(): Thickness;
    hh(a: Point): any;
    protected hm(a: Series, b: Point): any;
    protected ax(a: Series, b: any, c: Point, d: boolean): HighlightingInfo;
    protected ay(a: Series, b: any, c: Point, d: boolean): HighlightingInfo;
    gz(): number;
    g3(): number;
    g8(): number;
    get container(): ILegendOwner;
    get hasSubItems(): boolean;
    protected cz(): boolean;
    forSubItems(a: (arg1: any) => void): void;
    protected kt(a: (arg1: any) => void): void;
    ku(a: (arg1: Series) => boolean): void;
    i9(): string;
    op(): Brush;
    oq(): Brush;
    resolveLegendIndex(): number;
    be(): Series;
    protected get_c6(): boolean;
    get c6(): boolean;
    protected get_c3(): boolean;
    get c3(): boolean;
    protected get_c2(): boolean;
    get c2(): boolean;
    protected get_c5(): boolean;
    get c5(): boolean;
    protected get_c4(): boolean;
    get c4(): boolean;
    protected get_isVertical(): boolean;
    get isVertical(): boolean;
    protected get_dn(): boolean;
    get dn(): boolean;
    protected get_c8(): boolean;
    get c8(): boolean;
    protected get_c7(): boolean;
    get c7(): boolean;
    protected get_dv(): boolean;
    get dv(): boolean;
    protected get_du(): boolean;
    get du(): boolean;
    protected get_ea(): boolean;
    get ea(): boolean;
    protected get_db(): boolean;
    get db(): boolean;
    protected get_c9(): boolean;
    get c9(): boolean;
    protected get_ee(): boolean;
    get ee(): boolean;
    protected get_d2(): boolean;
    get d2(): boolean;
    protected get_d1(): boolean;
    get d1(): boolean;
    protected get_dz(): boolean;
    get dz(): boolean;
    protected get_dy(): boolean;
    get dy(): boolean;
    protected get_ec(): boolean;
    get ec(): boolean;
    protected get_eb(): boolean;
    get eb(): boolean;
    protected get_d8(): boolean;
    get d8(): boolean;
    protected get_d0(): boolean;
    get d0(): boolean;
    protected get_d6(): boolean;
    get d6(): boolean;
    protected get_d4(): boolean;
    get d4(): boolean;
    protected get_isStacked(): boolean;
    get isStacked(): boolean;
    protected get_di(): boolean;
    get di(): boolean;
    protected get_d5(): boolean;
    get d5(): boolean;
    protected get_da(): boolean;
    get da(): boolean;
    protected get_dp(): boolean;
    get dp(): boolean;
    protected get_d7(): boolean;
    get d7(): boolean;
    protected get_ed(): boolean;
    get ed(): boolean;
    bd(): Series;
    protected get_c0(): boolean;
    get c0(): boolean;
    protected get_dl(): boolean;
    get dl(): boolean;
    protected get_dk(): boolean;
    get dk(): boolean;
    protected get_dj(): boolean;
    get dj(): boolean;
    protected get_dm(): boolean;
    get dm(): boolean;
    protected get_dd(): boolean;
    get dd(): boolean;
    protected get_de(): boolean;
    get de(): boolean;
    fu(a: Point, b: number, c: Axis, d: ScalerParams, e: number): number;
    protected fv(a: Point, b: number, c: Axis, d: ScalerParams, e: number, f: number, g: (arg1: Point) => number): number;
    protected get_e2(): boolean;
    get e2(): boolean;
    protected ga(a: IList$1<number>, b: Point, c: Axis, d: ScalerParams, e: number, f: (arg1: Point) => number, g: boolean, h: boolean): number;
    f0(a: number, b: IList$1<number>, c: number, d: number, e: number, f: number, g: number, h: boolean): number;
    g7(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    fz(a: boolean): number;
    ah(a: Point): Point[][];
    ai(a: Point): Point[][];
    protected eo(a: Point, b: boolean): boolean;
    aj(a: CategoryAxisBase, b: List$1<number[]>, c: number, d: number, e: Point, f: boolean): number[][];
    protected eq(a: Point, b: boolean, c: PathGeometry): boolean;
    protected er(a: Point, b: PathGeometry): boolean;
    g5(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    fy(a: Point, b: Axis): number;
    g6(a: Point, b: boolean): number;
    g4(a: Point, b: boolean): number;
    f8(a: Point, b: boolean, c: boolean): number;
    o2(a: Point, b: boolean, c: boolean): Point;
    pb(a: Point): Rect;
    ak(a: Point): Rect[];
    pc(a: Point): Rect;
    al(a: Point): Rect[];
    pd(a: Point): Rect;
    pe(a: Point): Rect;
    protected es(a: Point, b: boolean): boolean;
    protected o4(a: Point, b: boolean, c: boolean, d: number, e: Axis, f: Axis, g: (arg1: Point, arg2: boolean, arg3: boolean) => number, h: (arg1: Point, arg2: boolean) => number, i: (arg1: Point, arg2: boolean) => number): Point;
    f4(a: Point, b: boolean, c: boolean): number;
    oy(a: Point, b: boolean, c: boolean): Point;
    f6(a: Point, b: boolean, c: boolean): number;
    o0(a: Point, b: boolean, c: boolean): Point;
    o3(a: Point, b: boolean, c: boolean): Point;
    f9(a: Point, b: boolean, c: boolean): number;
    oz(a: Point, b: boolean, c: boolean): Point;
    f5(a: Point, b: boolean, c: boolean): number;
    o1(a: Point, b: boolean, c: boolean): Point;
    f7(a: Point, b: boolean, c: boolean): number;
    g1(a: Point): number;
    f1(): number;
    fx(a: Point): number;
    hi(a: Point): any;
    cx(a: List$1<SeriesPointOfInterest>, b: boolean, c: number): boolean;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected raisePropertyChanged(a: string, b: any, c: any): void;
    protected get_hasMarkers(): boolean;
    get hasMarkers(): boolean;
    kx(): void;
    om(): Brush;
    on(): Brush;
    mv(): DataTemplate;
    ft(): number;
    o5(a: Point): Point;
    ox(a: Point): Point;
    hn(a: any, b: Point): any;
    eh(a: any): boolean;
    ap(a: Axis): AxisRange;
    aq(a: Rect): AxisRange;
    protected ao(a: AxisRange, b: NumericAxisBase, c: Rect): AxisRange;
    protected kq(): void;
    l0(a: boolean): void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    private kn;
    l1(a: boolean): void;
    protected eu: boolean;
    protected kd(): void;
    protected ki(): void;
    bw: SeriesView;
    l2(a: Rect, b: RenderSurface): void;
    lz(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    getEffectiveViewport1(a: SeriesView): Rect;
    o7(a: SeriesView): Rect;
    pa(a: Rect): Rect;
    o9(a: SeriesView): Rect;
    getEffectiveViewport(): Rect;
    lu(): void;
    protected get_cy(): boolean;
    get cy(): boolean;
    protected get_c1(): boolean;
    get c1(): boolean;
    private lv;
    lw(a: string): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    e3(a: Rect, b: Rect, c: SeriesView): boolean;
    kh(a: boolean, b: SeriesView): void;
    protected cs(): boolean;
    ct(a: SeriesView): boolean;
    li(a: Rect, b: Rect): void;
    protected mn(a: Rect, b: Rect): void;
    protected mm(a: Rect, b: Rect): void;
    as: ContentInfo;
    private co;
    get et(): boolean;
    set et(a: boolean);
    protected ks(a: Series): void;
    protected k8(): void;
    k2(): void;
    k7(): void;
    protected get_ds(): boolean;
    get ds(): boolean;
    protected get_isUsableInLegend(): boolean;
    get isUsableInLegend(): boolean;
    protected ld(): void;
    k9(): void;
    protected lj(): void;
    lk(): void;
    protected em: boolean;
    protected en: boolean;
    protected eg(): boolean;
    protected ll(a: boolean): void;
    private cp;
    protected get ev(): boolean;
    protected set ev(a: boolean);
    protected get ew(): boolean;
    protected v(): void;
    protected w(a: Visibility, b: Visibility): void;
    protected lc(): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    protected mc(): void;
    mk(a: Point): void;
    kp(): void;
    protected get_dr(): boolean;
    protected get dr(): boolean;
    cu: boolean;
    protected km(a: Series): void;
    get b5(): SyncLink;
    set b5(a: SyncLink);
    private b4;
    get ca(): SeriesViewer;
    set ca(a: SeriesViewer);
    private b9;
    get b8(): XamDataChart;
    set b8(a: XamDataChart);
    readonly fa: (sender: any, e: NotifyCollectionChangedEventArgs) => void;
    readonly bc: (sender: any, e: PropertyUpdatedEventArgs) => void;
    readonly ci: (sender: any, e: RectChangedEventArgs) => void;
    get itemsSource(): IEnumerable;
    set itemsSource(a: IEnumerable);
    static readonly ng: DependencyProperty;
    ch: IFastItemsSource;
    gs: (sender: any, e: FastItemsSourceEventArgs) => void;
    protected kk(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    get legend(): IChartLegend;
    set legend(a: IChartLegend);
    static readonly nm: DependencyProperty;
    get mq(): Control;
    set mq(a: Control);
    private mo;
    ho(): any;
    protected mp(): Control;
    get a0(): IChartLegend;
    set a0(a: IChartLegend);
    private az;
    ph: Visibility;
    get legendItemBadgeTemplate(): DataTemplate;
    set legendItemBadgeTemplate(a: DataTemplate);
    static readonly nj: DependencyProperty;
    ms: DataTemplate;
    private mu;
    oh: Brush;
    og: Brush;
    b3: StandardLegendItems;
    b2: StandardLegendItems;
    a9: LegendItemBadgeShape;
    a7: LegendItemBadgeMode;
    get legendItemTemplate(): DataTemplate;
    set legendItemTemplate(a: DataTemplate);
    static readonly nk: DependencyProperty;
    get mt(): DataTemplate;
    set mt(a: DataTemplate);
    static readonly m8: DependencyProperty;
    get g9(): number;
    set g9(a: number);
    static readonly nc: DependencyProperty;
    ml(): void;
    ko(): void;
    protected md(): void;
    cc: (time: number) => number;
    cd: (time: number) => number;
    cw: boolean;
    ha: number;
    gn: number;
    cr(): boolean;
    l8(): void;
    gh: number;
    private ff;
    protected get fp(): number;
    protected set fp(a: number);
    gr: number;
    private fc;
    protected get fm(): number;
    protected set fm(a: number);
    go: number;
    private fd;
    protected get fn(): number;
    protected set fn(a: number);
    gp: number;
    private fe;
    protected get fo(): number;
    protected set fo(a: number);
    gq: number;
    hp: any;
    oj: Brush;
    of: Brush;
    ok: Brush;
    ol: Brush;
    oo: Brush;
    oi: Brush;
    gf: number;
    gm: number;
    fl: number;
    fr: number;
    ot: PenLineCap;
    os: DoubleCollection;
    toolTip: any;
    private bi;
    get bj(): SeriesHighlightingMode;
    set bj(a: SeriesHighlightingMode);
    protected bk(): SeriesHighlightingMode;
    protected d9(a: SeriesHighlightingMode): boolean;
    private fb;
    get fj(): number;
    set fj(a: number);
    gd: number;
    dc: boolean;
    dq: boolean;
    dg: boolean;
    protected get_dh(): boolean;
    get dh(): boolean;
    gj: number;
    or: Color;
    e1: boolean;
    gk: number;
    gl: number;
    fq: number;
    fi: number;
    ma(): void;
    ge: number;
    fk: number;
    mb(): void;
    protected gi(): number;
    private cn;
    get df(): boolean;
    set df(a: boolean);
    el: boolean;
    private by;
    get bz(): SeriesVisibleRangeMode;
    set bz(a: SeriesVisibleRangeMode);
    b0(): SeriesVisibleRangeMode;
    b1: SeriesVisibleRangeMode;
    private bq;
    get br(): SeriesOutlineMode;
    set br(a: SeriesOutlineMode);
    bt(): SeriesOutlineMode;
    bs: SeriesOutlineMode;
    au(a: any): DataContext;
    hb: number;
    b7: TransitionInSpeedType;
    protected b6(): TransitionInSpeedType;
    hf: any;
    ly(): void;
    l3(): void;
    lx(): void;
    ke(): void;
    ky(): void;
    private static _e8;
    static e8(a: (arg1: number) => number, b: number, c: number): IEnumerable$1<number>;
    static e7(a: (arg1: number) => number, b: number): IEnumerable$1<number>;
    ov: PenLineCap;
    ou: PenLineCap;
    private bf;
    bg(): SeriesComponentsForView;
    l4(a: Canvas): void;
    gb(): number;
    gc(): number;
    private cq;
    protected get_ex(): boolean;
    protected set_ex(a: boolean): void;
    protected get ex(): boolean;
    protected set ex(a: boolean);
    get ej(): boolean;
    ef: boolean;
    kf(): void;
    av(a: any, b: Point, c: boolean): HighlightingInfo;
    aw(a: any, b: Point, c: boolean): HighlightingInfo;
    le(a: Point, b: any, c: any, d: boolean): void;
    l7(a: Point): void;
    private kb;
    private kg;
    ka(a: IChartLegend, b: IChartLegend): void;
    private kc;
    lt(a: IFastItemsSourceProvider): void;
    ls(a: IFastItemsSourceProvider): void;
    protected a1(): IChartLegend;
    protected ek(): boolean;
    ei(a: boolean): boolean;
    protected kl(a: Axis): void;
    protected lr(a: Axis): void;
    bh(): SeriesComponentsFromView;
    mf(a: Canvas): void;
    l6(a: Point, b: (arg1: any) => void): void;
    protected get_ez(): boolean;
    get ez(): boolean;
    ln(a: RenderingContext, b: RenderingContext): void;
    lp(a: Rect): void;
    kw(a: NotifyCollectionChangedEventArgs): void;
    k5(a: number, b: any, c: any): void;
    k1(): void;
    k3(a: number, b: any): void;
    k4(a: number, b: any): void;
    l9(): void;
    hr: any;
    gu: (arg1: any) => any;
    ep(a: Point, b: boolean): boolean;
    protected _coercionMethods: any;
    protected get_coercionMethods(): any;
    protected set_coercionMethods(a: any): void;
    get coercionMethods(): any;
    set coercionMethods(a: any);
    private cm;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    get expectFunctions(): boolean;
    set expectFunctions(a: boolean);
    at(a: Point, b: boolean): DataContext;
    private bm;
    get bp(): SeriesHitTestMode;
    set bp(a: SeriesHitTestMode);
    protected bo(): SeriesHitTestMode;
    private bl;
    get bn(): SeriesHitTestMode;
    set bn(a: SeriesHitTestMode);
    protected ce(a: string): IFastItemColumn$1<number>;
    protected cf(a: string): IFastItemColumn$1<number>;
    protected cg(a: string): IFastItemColumn$1<any>;
    protected get pf(): Rect;
    protected get_dx(): boolean;
    get dx(): boolean;
    protected get_dw(): boolean;
    get dw(): boolean;
    l5(a: Brush, b: Brush): void;
    cl: (arg1: SeriesViewer) => void;
    protected kj(a: any, b: any): void;
    hg(): any;
    protected kr(a: any): void;
    private ow;
    kz(a: Point): void;
    protected lb(a: Point): void;
    k0(): void;
    k6(): void;
    an(a: Axis): Axis;
    ag(): Axis[];
    f2(): number;
    static f3(a: IList$1<number>, b: ISortingAxis): number;
    la(): void;
    private fg;
    get fs(): number;
    set fs(a: number);
    private fh;
    get gg(): number;
    set gg(a: number);
    protected mj(): void;
    hj(a: any): any;
    get h5(): string;
    get hu(): string;
    get hv(): string;
    get h3(): string;
    get ia(): string;
    get h9(): string;
    get h7(): string;
    protected me(): void;
    am(): ActualLegendItemBadgeShape;
    protected a8(a: LegendItemBadgeShape): LegendItemBadgeShape;
    private ba;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class MarkerSeries extends Series {
    static $t: Type;
    pq: MarkerSeriesView;
    constructor();
    pg(): Thickness;
    lh(a: SeriesView): void;
    protected get_hasMarkers(): boolean;
    om(): Brush;
    on(): Brush;
    mv(): DataTemplate;
    pr: MarkerType;
    private pm;
    get pn(): MarkerOutlineMode;
    set pn(a: MarkerOutlineMode);
    pp(): MarkerOutlineMode;
    mh(a: MarkerOutlineMode): void;
    po: MarkerOutlineMode;
    private pi;
    get pj(): MarkerFillMode;
    set pj(a: MarkerFillMode);
    pl(): MarkerFillMode;
    mg(a: MarkerFillMode): void;
    mi(a: number): void;
    pk: MarkerFillMode;
    qd: DataTemplate;
    pw: number;
    ft(): number;
    qb: DataTemplate;
    qc: DataTemplate;
    private static qa;
    static get qe(): DataTemplate;
    get qt(): Brush;
    set qt(a: Brush);
    static readonly qi: DependencyProperty;
    qr: Brush;
    qu: Brush;
    qs: Brush;
    qv: Style;
    pv: boolean;
    pt(): boolean;
    protected lc(): void;
    protected lm(a: any, b: string, c: any, d: any): void;
    static p0(a: MarkerType): string;
    static ps(a: Series, b: MarkerType): MarkerType;
    protected md(): void;
    protected kr(a: any): void;
    protected pu(a: Point, b: boolean): boolean;
    at(a: Point, b: boolean): DataContext;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class SyncLink extends FrameworkElement implements INotifyPropertyChanged, IFastItemsSourceProvider {
    static $t: Type;
    constructor();
    ai: string;
    protected am(a: any, b: string, c: any, d: any): void;
    releaseFastItemsSource(a: IEnumerable): IFastItemsSource;
    static ah: (arg1: IEnumerable) => IFastItemsSource;
    private static ad;
    getFastItemsSource(a: IEnumerable): IFastItemsSource;
    ae(a: IEnumerable): IFastItemsSource;
    private af;
    aq: Rect;
    private ar;
    private as;
    get ag(): IList$1<SeriesViewer>;
    ab: ChartCollection;
    private aj;
    ak(a: SeriesViewer, b: Point): void;
    al(a: SeriesViewer, b: Rect): void;
    ao(a: SeriesViewer, b: Rect): void;
    ap(a: SeriesViewer, b: Rect, c: boolean): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected an(a: string, b: any, c: any): void;
}
/**
 * @hidden
 */
export declare class SyncLinkManager extends Base {
    static $t: Type;
    private static b;
    static instance(): SyncLinkManager;
    private d;
    get e(): number;
    constructor();
    getLink(a: string): SyncLink;
    releaseLink(a: SyncLink): void;
}
/**
 * @hidden
 */
export declare class SyncManager extends Base {
    static $t: Type;
    static e(a: SeriesViewer): void;
    static c(a: SeriesViewer): void;
    static b(a: SeriesViewer, b: string, c: string): void;
    static d(a: DependencyObject, b: SyncSettings): void;
    static a(a: DependencyObject): SyncSettings;
}
/**
 * @hidden
 */
export declare class ChartCollection extends ObservableCollection$1<SeriesViewer> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class SeriesCollection extends ObservableCollection$1<Series> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class PlotAreaMouseEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Point, c: Point);
    private _chartPosition;
    get chartPosition(): Point;
    set chartPosition(a: Point);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    private _isDuringManipulation;
    get isDuringManipulation(): boolean;
    set isDuringManipulation(a: boolean);
    private _viewer;
    get viewer(): SeriesViewer;
    set viewer(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class PlotAreaMouseButtonEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Point, c: Point);
    private _chartPosition;
    get chartPosition(): Point;
    set chartPosition(a: Point);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    private _manipulationOccurred;
    get manipulationOccurred(): boolean;
    set manipulationOccurred(a: boolean);
    private _viewer;
    get viewer(): SeriesViewer;
    set viewer(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class ChartCursorEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any);
    toString(): string;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _seriesViewer;
    get seriesViewer(): SeriesViewer;
    set seriesViewer(a: SeriesViewer);
    get chart(): XamDataChart;
}
/**
 * @hidden
 */
export declare class DataChartMouseButtonEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseButtonEventArgs);
    toString(): string;
    protected g: MouseButtonEventArgs;
    get handled(): boolean;
    set handled(a: boolean);
    getPosition(a: UIElement): Point;
    get originalSource(): any;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class ChartMouseEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseEventArgs);
    toString(): string;
    private f;
    getPosition(a: UIElement): Point;
    get originalSource(): any;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class AxisComponentsForView extends Base {
    static $t: Type;
    a: AxisLabelPanelBase;
}
/**
 * @hidden
 */
export declare class AxisLabelPanelBaseView extends Base {
    static $t: Type;
    protected a: AxisLabelPanelBase;
    av: Path;
    constructor(a: AxisLabelPanelBase);
    aa(a: FrameworkElement, b: Rect, c: number, d: number, e: number, f: number): void;
    z(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number): void;
    ad(a: FrameworkElement): void;
    ag(a: any): void;
    ah(a: any, b: Size): void;
    ai(a: FrameworkElement, b: number): void;
    aq(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number, i: number): void;
    x(a: TextBlock, b: number, c: number, d: number): string;
    ae(): void;
    g(): IEnumerable$1<any>;
    l(a: any): number;
    n(a: any): number;
    am(): void;
    m(a: any): number;
    w(a: any): number;
    ac(): void;
    aj(): void;
    protected e: RenderingContext;
    f(): RenderingContext;
    ak(a: RenderingContext): void;
    y(): void;
    protected al(): void;
    private au;
    protected ao(a: TextBlock): void;
    an(): void;
    d(): FontInfo;
    as(): Brush;
    private c;
    af(): void;
    private h;
    private ar;
    private i;
    j(): number;
    k(): number;
    protected ap(): void;
    ab(a: Size): void;
    protected aw(): Thickness;
    v(): number;
    s(): number;
    t(): number;
    u(): number;
    at(): GeometryCollection;
    b(): PathRenderingInfo;
    r(): number;
    p(): number;
    q(): number;
    o(): number;
}
/**
 * @hidden
 */
export declare class AxisView extends Base implements ISchedulableRender {
    static $t: Type;
    protected a: Axis;
    constructor(a: Axis);
    ag(): void;
    ai(a: any): void;
    a7: Path;
    a8: Path;
    ba: Path;
    a9: Path;
    ax(): TextBlock;
    aq(a: TextBlock): void;
    as(a: TextBlock): void;
    ar(a: TextBlock): void;
    bc(): Rectangle;
    p(a: Rectangle): void;
    r(a: Rectangle): void;
    q(a: Rectangle): void;
    aj(): void;
    m(): boolean;
    get index(): number;
    ad(): void;
    ab(): void;
    x(): void;
    av(a: Visibility): void;
    an(): void;
    w(a: AxisLabelSettings): void;
    private b;
    c(): AxisComponentsFromView;
    z(a: GeometryCollection): void;
    ay(): GeometryCollection;
    e(): PathRenderingInfo;
    a1(): GeometryCollection;
    az(): GeometryCollection;
    f(): PathRenderingInfo;
    a0(): GeometryCollection;
    g(): PathRenderingInfo;
    protected get d(): AxisLabelPanelBase;
    at(a: Axis, b: Rect, c: Rect): void;
    y(): void;
    ap(a: number): void;
    au(a: List$1<any>, b: List$1<LabelPosition>): void;
    ao(a: number): void;
    v(): void;
    private h;
    o(a: number): string;
    n(dataItem_: any): any;
    protected k: RenderingContext;
    j: RenderingContext;
    af(a: RenderingContext, b: RenderingContext): void;
    private _isDirty;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    protected ae(): void;
    undirty(a: boolean): void;
    private bb;
    protected al(a: boolean): void;
    postRender(): void;
    private a5;
    protected am(): void;
    ac(): void;
    aa(a: SeriesViewer): void;
    u(a: SeriesViewer): void;
    i(): FontInfo;
    l(): boolean;
    ak(): void;
    t(): void;
    aw(): void;
    s(a: AxisLabelSettings, b: string): void;
    preRender(): void;
    isValid(): boolean;
    a2(a: TextBlock): Point;
    a3(): Point;
    a6(): Rect;
    a4(a: TextBlock): Point;
    bd(a: TextBlock): Thickness;
    ah(): void;
}
/**
 * @hidden
 */
export declare class CategoryAxisBaseView extends AxisView {
    static $t: Type;
    protected be: CategoryAxisBase;
    constructor(a: CategoryAxisBase);
    o(a: number): string;
    bf(a: List$1<any>): number;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanelBaseView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected ax: HorizontalAxisLabelPanelBase;
    constructor(a: HorizontalAxisLabelPanelBase);
    az(): void;
    ay(): boolean;
    a0(a: List$1<Rect>): void;
}
/**
 * @hidden
 */
export declare class NumericAxisBaseView extends AxisView {
    static $t: Type;
    protected be: NumericAxisBase;
    constructor(a: NumericAxisBase);
    bf(): void;
    o(a: number): string;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanelView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected ax: VerticalAxisLabelPanel;
    constructor(a: VerticalAxisLabelPanel);
    ay(): void;
    d(): FontInfo;
    protected aw(): Thickness;
    as(): Brush;
    az(a: List$1<Rect>, b: number): void;
}
/**
 * @hidden
 */
export declare class XamDataChartView extends SeriesViewerView {
    static $t: Type;
    constructor(a: XamDataChart);
    protected fi: XamDataChart;
    fm(a: any): void;
    protected dp(): void;
    d1(): void;
    fr: Brush;
    fn: Brush;
    fo: Brush;
    fq: Brush;
    fp: Brush;
    fk: number;
    fl: number;
    protected dy(): void;
    fj: FontInfo;
}
/**
 * @hidden
 */
export declare class SeriesView extends Base implements ISchedulableRender, IProvidesViewport {
    static $t: Type;
    protected e: Series;
    s: boolean;
    constructor(a: Series);
    getDefaultTooltipTemplate(): string;
    ap(): void;
    j(): IExecutionContext;
    private h;
    protected get i(): IExecutionContext;
    d: DataContext;
    as(): void;
    getEffectiveViewport(): Rect;
    az(): void;
    aj(): void;
    get w(): DomRenderer;
    private _isDirty;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    protected get_index(): number;
    get index(): number;
    protected aq(): void;
    undirty(a: boolean): void;
    private bw;
    au(): void;
    private bn;
    bq(): Brush;
    v: number;
    private u;
    protected a4(a: boolean): void;
    private br;
    protected bd(a: any, b: number, c: boolean): void;
    protected bg(a: any, b: number, c: boolean): void;
    protected aa(a: number, b: boolean): any;
    protected ab(a: number): any;
    protected ac(a: number): any;
    protected be(a: any, b: number): void;
    protected bh(a: any, b: number): void;
    protected bf(a: any, b: number): void;
    protected bi(a: any, b: number): void;
    protected ba(a: boolean): void;
    protected bb(): void;
    protected bc(): void;
    private bm;
    protected bp(a: number): Brush;
    protected bo(): Brush;
    protected a6(a: RenderingContext, b: boolean): void;
    protected a5(a: RenderingContext, b: boolean): void;
    ax(): void;
    am(): void;
    an(): void;
    private f;
    g(): SeriesComponentsFromView;
    a9(a: Canvas): void;
    t(): boolean;
    aw(): void;
    av(): void;
    a7(): void;
    ah(): void;
    a8(): void;
    ai(): void;
    c(a: any): DataContext;
    protected k: RenderingContext;
    protected l: RenderingContext;
    ar(a: RenderingContext, b: RenderingContext): void;
    private bs;
    get bu(): Rect;
    set bu(a: Rect);
    bt: Rect;
    protected get_bv(): Rect;
    get bv(): Rect;
    private m;
    get q(): boolean;
    set q(a: boolean);
    ak(a: SeriesViewer): void;
    a: CanvasRenderScheduler;
    ag(a: SeriesViewer): void;
    postRender(): void;
    protected a0(): void;
    b(a: number): DataContext;
    a2(a: RenderSurface): void;
    al(a: any): void;
    bj(): void;
    at(): void;
    ay(): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    o(): boolean;
    protected r: boolean;
    bk(): void;
    a3(): void;
    protected af(): void;
    ao(): void;
    preRender(): void;
    isValid(): boolean;
    n: boolean;
    p: boolean;
    a1(a: RenderSurface): void;
    ad: string;
    bl(type_: StandardLegendItems): DataTemplate;
}
/**
 * @hidden
 */
export declare abstract class MarkerSeriesView extends SeriesView {
    static $t: Type;
    protected b1: MarkerSeries;
    private b5;
    private b7;
    private b6;
    constructor(a: MarkerSeries);
    as(): void;
    cg(): void;
    cq(): Size;
    cn(a: boolean): void;
    protected b4: List$1<Marker>;
    b0(): Marker;
    abstract cf(a: (arg1: Marker) => void): void;
    cj(a: Marker): void;
    cl(a: Marker): void;
    ck(a: Marker): void;
    b2(): boolean;
    ce(): void;
    b8(): void;
    cp(a: Marker): Rect;
    cb(a: string): void;
    cc(): void;
    b9(): void;
    cd(): void;
    ca(): void;
    cm(): void;
    b3: boolean;
    protected bh(a: any, b: number): void;
    private bx;
    protected bi(a: any, b: number): void;
    b(a: number): DataContext;
    private co;
    protected a5(a: RenderingContext, b: boolean): void;
    ch(a: HashPool$2<any, Marker>): void;
    ci(a: Pool$1<Marker>): void;
    by(a: Point): Marker;
    private bz;
}
/**
 * @hidden
 */
export declare class ChartAxisRangeChangedEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Axis, c: number, d: number, e: number, f: number);
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
    private _axis;
    get axis(): Axis;
    set axis(a: Axis);
    private _oldMinimumValue;
    get oldMinimumValue(): number;
    set oldMinimumValue(a: number);
    private _minimumValue;
    get minimumValue(): number;
    set minimumValue(a: number);
    private _oldMaximumValue;
    get oldMaximumValue(): number;
    set oldMaximumValue(a: number);
    private _maximumValue;
    get maximumValue(): number;
    set maximumValue(a: number);
}
