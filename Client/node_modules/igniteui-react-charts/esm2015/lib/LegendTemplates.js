/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Point_$type, markType } from "igniteui-react-core";
import { DataTemplate } from "igniteui-react-core";
import { Series } from "./Series";
import { RenderingContext } from "igniteui-react-core";
import { DataTemplateRenderInfo } from "igniteui-react-core";
import { CanvasViewRenderer } from "igniteui-react-core";
import { Defaults } from "./Defaults";
import { PathFigure } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { Line } from "igniteui-react-core";
import { EllipseGeometry } from "igniteui-react-core";
import { DataTemplateMeasureInfo } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { LegendItemHelper } from "igniteui-react-core";
/**
 * @hidden
 */
export let LegendTemplates = /*@__PURE__*/ (() => {
    class LegendTemplates extends Base {
        static af(a) {
            let b = a.am();
            switch (b) {
                case 3: return LegendTemplates.y;
                case 4: return LegendTemplates.aa;
                case 0: return LegendTemplates.z;
                case 8: return LegendTemplates.ae;
                case 9: return LegendTemplates.ac;
                case 5: return LegendTemplates.ah;
                case 1:
                case 2: return LegendTemplates.ad;
                case 6:
                case 7: return LegendTemplates.ab;
            }
            return LegendTemplates.ah;
        }
        static a(a) {
            return new RenderingContext(new CanvasViewRenderer(), a.context);
        }
        static v(a) {
            let b = typeCast(Series.$, a.series);
            if (b == null || b.a7 == 0) {
                a.thickness = Defaults.v;
            }
            else {
                a.thickness = b.fl;
            }
            if (b == null) {
                a.actualItemBrush = a.itemBrush;
            }
            else {
                a.actualItemBrush = b.og;
            }
            if (b == null) {
                a.outline = a.actualItemBrush;
            }
            else {
                a.outline = b.oh;
            }
        }
        static b(a, b) {
            return a;
        }
        static c(a, b) {
            return a;
        }
        static u(a, b, c, d, e, f, g, h) {
            let i = DeviceUtils.g(Defaults.w - 2);
            let j = DeviceUtils.g(Defaults.u - 2);
            e = e + 1;
            f = f + 1;
            let k = LegendTemplates.c(f, j);
            let l = LegendTemplates.c(h, j);
            let m = LegendTemplates.b(e, i);
            let n = LegendTemplates.b(g, i);
            let o = ((() => {
                let $ret = new PathFigure();
                $ret.isClosed = true;
                $ret.isFilled = true;
                return $ret;
            })());
            o._startPoint = { $type: Point_$type, x: m, y: l };
            o._segments.add(new LineSegment(0, { $type: Point_$type, x: m, y: l }));
            o._segments.add(new LineSegment(0, { $type: Point_$type, x: n, y: l }));
            o._segments.add(new LineSegment(0, { $type: Point_$type, x: n, y: k }));
            o._segments.add(new LineSegment(0, { $type: Point_$type, x: m, y: k }));
            let p = new PathGeometry();
            p.c.add(o);
            let q = new Path();
            q.ak = p;
            q.ac = b;
            q._stroke = c;
            q._fill = d;
            let r = LegendTemplates.a(a);
            r.s(q);
        }
        static s(a) {
            let b = a.data;
            let c = b.series;
            LegendTemplates.v(b);
            let d = DeviceUtils.g(Defaults.w);
            let e = DeviceUtils.g(Defaults.u);
            let f = new Line();
            f.ak = 0;
            f.am = e / 2;
            f.al = d;
            f.an = e / 2;
            f._stroke = b.actualItemBrush;
            if (c.a7 == 0) {
                f.ac = Defaults.v;
            }
            else {
                f.ac = c.fl;
            }
            let g = LegendTemplates.a(a);
            g.r(f);
        }
        static r(a, b, c) {
            let d = a.data;
            LegendTemplates.v(d);
            let e = DeviceUtils.g(Defaults.w);
            let f = DeviceUtils.g(Defaults.u);
            let g = e / 2;
            let h = f / 2;
            let i = new EllipseGeometry();
            i.e = { $type: Point_$type, x: LegendTemplates.b(g, e), y: LegendTemplates.c(h, f) };
            i.c = g - 1;
            i.d = h - 1;
            let j = new Path();
            j.ak = i;
            j.ac = d.thickness;
            j._stroke = d.outline;
            j._fill = d.actualItemBrush;
            let k = LegendTemplates.a(a);
            k.s(j);
        }
        static t(a, b = 0) {
            let c = a.data;
            let d = DeviceUtils.g(Defaults.w - b);
            let e = DeviceUtils.g(Defaults.u - b);
            let f = new DataTemplateMeasureInfo();
            f.passInfo = a.passInfo;
            f.width = d;
            f.height = e;
            f.data = a.data;
            f.context = a.context;
            f.renderContext = a.renderContext;
            let g = c.actualItemBrush;
            let h = c.itemBrush;
            let i = c.series;
            let j = i.mv();
            c.actualItemBrush = i.om();
            c.outline = i.on();
            if (i.a7 == 1) {
                c.thickness = i.ft();
            }
            else {
                c.thickness = Defaults.ab;
            }
            if (j != null && j.measure != null && j.render != null) {
                let k = new DataTemplateRenderInfo();
                k.passInfo = a.passInfo;
                k.availableWidth = f.width;
                k.availableHeight = f.height;
                k.xPosition = (a.availableWidth / 2);
                k.yPosition = (a.availableHeight / 2);
                k.data = a.data;
                k.context = a.context;
                k.renderContext = a.renderContext;
                j.render(k);
            }
            c.itemBrush = h;
            c.actualItemBrush = g;
        }
        static j(a) {
            let b = a.data;
            LegendTemplates.v(b);
            LegendTemplates.r(a, Defaults.w, Defaults.u);
        }
        static n(a) {
            let b = a.data;
            let c = b.series;
            LegendTemplates.s(a);
            if (c.a7 == 1) {
                LegendTemplates.t(a, Defaults.t);
            }
        }
        static o(a) {
            LegendTemplates.t(a, 2);
        }
        static q(a) {
            let b = a.data;
            LegendTemplates.v(b);
            LegendTemplates.u(a, b.thickness, b.outline, b.actualItemBrush, 0, 0, Defaults.w, Defaults.u);
        }
        static p(a) {
            let b = a.data;
            let c = b.series;
            LegendTemplates.v(b);
            if (c.a7 == 0) {
                let d = Defaults.v;
                let e = b.actualItemBrush;
                let f = c.oh;
                let g = Defaults.w;
                let h = Defaults.u;
                LegendTemplates.u(a, d, f, e, 0, 0, g, h);
            }
            else {
                let i = Defaults.v;
                let j = b.actualItemBrush;
                let k = c.op();
                let l = Defaults.w / 2;
                let m = Defaults.w;
                let n = Defaults.u;
                LegendTemplates.u(a, i, j, j, 0, 0, l, n);
                LegendTemplates.u(a, i, k, k, l, 0, m, n);
            }
        }
        static i(a) {
            let b = a.data;
            LegendTemplates.v(b);
            let c = 0;
            let d = Defaults.w;
            let e = (Defaults.u * 0.25);
            let f = (Defaults.u * 0.75);
            LegendTemplates.u(a, b.thickness, b.outline, b.actualItemBrush, c, e, d, f);
        }
        static l(a) {
            let b = a.data;
            LegendTemplates.v(b);
            let c = (Defaults.w * 0.25);
            let d = (Defaults.w * 0.75);
            let e = Defaults.u;
            let f = 0;
            LegendTemplates.u(a, b.thickness, b.outline, b.actualItemBrush, c, f, d, e);
        }
        static m(a) {
            let b = a.data;
            let c = BrushUtil.g(0, 0, 0, 0);
            let d = BrushUtil.g(0, 0, 0, 0);
            LegendTemplates.u(a, Defaults.v, c, d, 0, 0, Defaults.w, Defaults.u);
        }
        static k(a) {
        }
        static g(a) {
            let b = a.data;
            let c = b.series;
            let d = c.legendItemBadgeTemplate;
            if (d == null) {
                d = LegendTemplates.af(c);
            }
            let e = c.hp;
            if (e == null) {
                e = "Series Title";
            }
            LegendItemHelper.d(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo, c.a0 != null && c.a0.isFinancial, c.fs, c.gg);
        }
        static resolveLegendItemTemplate(a) {
            switch (a) {
                case 0: return LegendTemplates.w;
                case 1: return LegendTemplates.x;
            }
            return LegendTemplates.w;
        }
        static e(a) {
            let b = a.data;
            let c = b.series;
            let d = c.legendItemBadgeTemplate;
            if (d == null) {
                d = LegendTemplates.af(c);
            }
            let e = b.itemLabel;
            if (e == null) {
                e = "Series Item";
            }
            LegendItemHelper.c(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo);
        }
        static f(a) {
        }
        static d(a) {
        }
        static h(a) {
        }
    }
    LegendTemplates.$t = /*@__PURE__*/ markType(LegendTemplates, 'LegendTemplates');
    LegendTemplates.z = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.j;
        return $ret;
    })());
    LegendTemplates.ae = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.o;
        return $ret;
    })());
    LegendTemplates.ad = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.n;
        return $ret;
    })());
    LegendTemplates.ah = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.q;
        return $ret;
    })());
    LegendTemplates.ab = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.p;
        return $ret;
    })());
    LegendTemplates.y = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.i;
        return $ret;
    })());
    LegendTemplates.aa = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.l;
        return $ret;
    })());
    LegendTemplates.ac = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.m;
        return $ret;
    })());
    LegendTemplates.w = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.f;
        $ret.render = LegendTemplates.g;
        return $ret;
    })());
    LegendTemplates.x = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.d;
        $ret.render = LegendTemplates.e;
        return $ret;
    })());
    return LegendTemplates;
})();
//# sourceMappingURL=LegendTemplates.js.map
